{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 Table-Driven Customization of Web Applications\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Introduction\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab many approaches to customizing software. Most are imperative command based. Can\u8217't get around it.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab there are successful systems for visual SQL queries: Airtable, Sieuferd. Even spreadsheets.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab what if you could see the data queries powering a website and directly modify them yourself?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab we call this table-driven customization.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To make it work with the real world, we develop Wildcard, shim this on top of existing web apps. Show in Section Examples that it really works! can do tons of useful stuff with real apps.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Architecture: Describe implementation of Wildcard. We\u8217've developed generic abstractions that make this system even more extensible in the future. we also propose a future architecture where apps are built for this; they expose their data queries and their structured data results.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Design Principles: explain ideas behind the system, generalizable to software customization more generally\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Related Work: table editors,\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Examples\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i This section still todo. Borrow heavily from Convivial paper, but extend with newer results}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Just use airbnb + expedia from Convivial paper?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab instacart + hacker news?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab summarize/mention all 12 sites we\u8217've used it with\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab real usage:\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 1 externally contributed adapter\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab flux adapter in actual use by Sergio\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 System architecture\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The basic data unit in table-driven customization is a Table: an ordered list of tuples, each of which has an ID and some attributes. The user always sees a single table in the table editor, but this table is the result of combining data across one or more underlying tables, much like viewing the result of a SQL query across multiple database tables. Each individual table\u8217's data is managed by a \u8220"table adapter\u8221" component, and a query engine coordinates across the various table adapters.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 ({\i Todo: drive this explanation via concrete Instacart example. Add a figure.}) For example, one table adapter manages scraping data from the DOM of a site, while another manages extracting data from AJAX requests. Each table adapter produces a table of data, and the two are joined together by a shared ID column to produce what looks like a single table of data extracted from the site. Similarly, when the user makes annotations on a site, these annotations are handled by a third table adapter, which manages a data table stored in the browser\u8217's local storage.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Table adapter API\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In order to promote uniformity within the system, we\u8217've defined a small abstract API, which all table adapters conform to. (Todo: formalize this more, make it more specific?)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Output: data table}:The main purpose of a table adapter is to return a table representing some data source. The table is live-updating: a table adapter can produce a new version of its data table at any point (e.g., updating the data table in response to a change in a website\u8217's DOM). When this happens the new data is pushed to the editor and the query results are refreshed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Table editors also accept various incoming commands.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Input: record edits}:The editor can request to a table adapter to make an edit to a record. The meaning of making an edit can vary depending on the adapter: in the local storage adapter, an annotation can be persisted into local storage; in the DOM scraping adapter, an edit can represent filling in a form field. An adapter can also mark values as read-only if it wouldn\u8217't be meaningful to edit them; for example, the DOM scraping adapter typically marks page content as read-only, except for editable form fields.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i Input: query information}:The query engine also sends each table adapter information about the entire cross-table query view being created by the user. This functionality is currently mainly used by the DOM scraping adapter to make changes to the original web page:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab observes the sort order of the query view to re-order rows in the page\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab observes the content of other joined tables to render annotations in the page\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab observes the currently selected row in the UI, to highlight the corresponding row in the page\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Table adapters\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Here we describe the three types of table adapters which we have implemented so far to power the customizations shown above. Then, to demonstrate the generality of the table adapter paradigm, we describe three more hypothetical types of table adapters which could extend the power of the Wildcard system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Existing Adapters\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A {\b DOM scraping adapter} extracts data from the DOM of a web page, and manipulates the DOM to re-order rows, edit form entries, and inject annotations. A programmer only needs to write a single function which returns scraped data and pointers to relevant DOM elements; the Wildcard framework uses this function to implement the rest of the needed functionality.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 ({\i do we want to call DOM scraping adapter a \u8220"live\u8221" adapter because its data is also shown elsewhere\u8230??})\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An {\b AJAX scraping adapter} intercepts AJAX requests made by a web page, and extracts information from those requests. A programmer writes a function which specifies how to extract data from an AJAX request, and the framework handles the details of actually intercepting requests and calling the programmer-defined function.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\b local storage adapter} simply stores a table of data in the browser.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Future Adapters\par}
{\pard \ql \f0 \sa180 \li0 \fi0 we have intentionally designed the table adapter API to be general enough to encapsulate other types of data and additional functionality in the future. Here are three concrete examples of such possibilities:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Integrated website adapters}: We have taken pains to design a customization system which is not limited to web scraping as the only means for integrating with existing sites, and can also accommodate first party developers adding support for table-driven customization directly into their own websites. A DOM Scraping table adapter could be swapped out for such an \u8220"integrated website adapter,\u8221" which implements the exact same interface as a scraping adapter but by directly accessing the internal state of the user interface, without needing any scraping logic.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 While we have not yet created a fully operational integrated website adapter, we think it is possible to create such adapters for existing frontend web frameworks which result in minimal effort on the part of the application developers. For example, we have created an early prototype of a plugin for the Redux state management library, which uses the Model-View-Update pattern that represents the entire state of a user interface as a single centralized object. To configure an integrated website adapter for such an existing application, the user can specify a function projecting the centralized application state as a table, and handlers for how data edits to the table should affect the state.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Shared storage adapter}: It would be useful to share user annotations between people and across devices\u8212-for example, collaboratively taking notes with friends on a list of options for places to stay on Airbnb. The existing Local Storage Adapter could be extended to share live synchronized data with other users. This could be achieved through a centralized web server (perhaps an existing service like Google Sheets capable of storing tabular data), or through P2P connections which might improve the privacy guarantees available for the shared annotations.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Third party API data adapter}: Currently, the main mechanism for including data from web APIs in Wildcard is using spreadsheet formulas. However, a web API could also be wrapped to expose a table API that would dynamically create tables in response to queries. For example, when fetching walkability scores for many GPS locations, the query engine could request a table of walkability scores for various pairs of latitude and longitude, and the table adapter could dynamically perform API queries to populate a result table. ({\i todo: why is this better than spreadsheet formulas? I don\u8217't think it offers any more room for batching performance optimization because we\u8217've already framed formulas as whole-column, not row specific})\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Query engine\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The query engine is responsible for coordinating across multiple table adapters. It joins data across multiple tables and creates a single result table which is shown to the user through the editor. It also handles all user interactions and routes appropriate messages to each table adapter.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 First, every query involves a primary DOM scraping table adapter which associates records in the result with elements in the application\u8217's user interface. At minimum, the primary table adapter needs to return record IDs and have the ability to manipulate the application\u8217's UI. It can also optionally return data about each record.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Next, additional tables (AJAX data, local storage data) are left joined by ID. ({\i todo: discuss IDs here?}) Finally, the result table can be sorted and filtered by any column.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One way to think of this model is a tiny constrained subset of the SQL query model. We\u8217've found that this simple model has proven sufficient for meeting the needs of customization in practice, and minimizes the complexity of supporting more general and arbitrary queries. But because it fits into the general SQL paradigm, it could theoretically be extended to support more types of queries.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab formulas: do they go here?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Table editor\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Our editor is closer to visual SQL query engines like Sieuferd or Airtable than a freeform spreadsheet.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab cell editors\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Note that there could be other entire table editors\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Design aspects\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Data-oriented programming\par}
{\pard \ql \f0 \sa180 \li0 \fi0 There have been many attempts at simplifying aspects of traditional programming to enable non-programmer end users to perform customization. End user scripting languages (AppleScript, VBA, Chickenfoot, CoScripter) have innovated at the syntax level, aiming to improve ease-of-use. Visual programming environments (Mac Automator, Zapier) go further by eliminating text syntax entirely, but maintain the same computational model. Programming-by-demonstration and macro recording environments (Applescript, Helena, WebVCR) remove some of the initial programming burden by starting with concrete demonstrations, but typically require programming later in the process.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 However, all of these approaches share something in common: {\b an imperative programming model}. They all involve a list of commands executed in sequence, with control flow constructs like conditionals and loops, and mutable variables. This makes some intuitive sense: many customizations seem most naturally expressed as a series of commands, each of which has a side effect on the UI: first enter this value, then click this button, etc. The result is that end users eventually need to become familiar with all of these traditional imperative programming constructs, even if only in diluted form. (todo: bolster the case that this is a barrier to learning)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Imperative programming is not the only possible model. Spreadsheets have demonstrated another computational model: data editing via direct manipulation, combined with pure functional expressions for computation, with automatic reactive updates provided by the runtime. We call this a data-oriented model, because the user is focused on editing data values and producing the correct derived data values, rather than encoding a sequence of commands. The success of spreadsheets with end user programmers suggests that finding a way to apply data-oriented programming model to software customization might enable more people to modify their software. However, it\u8217's not immediately obvious how the spreadsheet paradigm applies to customization.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A key insight from our work is that, rather than representing customization as a series of commands issued to an existing application, we can present a projected view of the application\u8217's internal state, and let the user directly edit that projection as a means of customizing the application. In some sense, this is similar to the DOM inspector, which provides a user with an alternate representation of the UI that they can directly manipulate (e.g., by selecting an element and deleting it from the DOM tree). But rather than provide a low-level view of the user interface elements, we instead provide a higher-level view of the semantic state of the application.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Black-box + semantic\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Software customization tools typically fall into one of two categories: black-box, or semantic.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Black-box customization tools} enable customization without using official extension APIs, enabling a broader range of customizations on top of more applications. For example, web browser extensions have demonstrated the utility of customizing websites through manipulating the DOM, without needing explicit extension APIs to be built in. However, black-box customization comes with a corresponding cost: these tools can typically only operate at a low level of abstraction, e.g.\u160?manipulating user interface elements. This makes it harder for end users to write scripts, and makes the resulting scripts more brittle. (todo: support this claim more, provide examples)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Semantic customization tools} use explicit extension APIs provided by the application developer. Examples of this include accessing a backend web API, or writing a customization in Applescript that uses an application-specific API. The main benefit is that this allows the extension author to work with meaningful concepts in the application domain\u8212-\u8220"create a new calendar event\u8221" rather than \u8220"click the button that says new event.\u8221"\u8212-which makes customizations easier to build and more robust. However, this style limits the range of extensions that can be built, to only those which the official plugin API supports.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 (Footnote this paragraph?) This categorization is slightly oversimplified, and there are existing customization ecosystems that span both categories. For example, part of the success of browser extensions stems from the fact that the DOM encourages the use of standardized semantic UI elements; even if an app developer doesn\u8217't anticipate customization, merely using of semantic and accessible HTML creates a collateral benefit of easier extension. Another example of a middle ground is AppleScript, which provides system-wide low-level APIs for manipulating GUIs as a means of black-box customization, while also enabling developers to optionally add application-specific APIs to add support for semantic customization.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 With Wildcard, we use a hybrid approach that takes the best of both worlds. Programmers implement an API wrapper that is internally implemented as a black-box customization, but externally provides a semantic interface to the application. End users get an ergonomic and simplified customization experience, but without the need to depend on a first-party application developer exposing extension APIs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 One way to view this approach is as introducing a new abstraction barrier into black-box extension. Typically, a black box customization script combines two responsibilities: 1) mapping the low-level details of a user interface to semantic constructs (e.g., using CSS selectors to find certain page elements), and 2) the actual logic of the specific customization. (todo: could easily show examples of this from browser extensions, Chickenfoot, etc) Even though the mapping logic is often more generic than the specific customization (e.g., finding a given input element is independent of what text to insert into that element), the intertwining of these two responsibilities in a single script makes it very difficult to share the mapping logic across scripts. With Wildcard we propose a decoupling of these two layers: a community-maintained mapping layer, shared across many specific customizations by individual users. This architecture has been successfully used by projects like Gmail.js, an open source project that creates a convenient API for browser extensions to interface with the Gmail web email client.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Proximity to use\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i borrow from convivial paper\u8217's discussion of in-place}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab here\u8217's where \u8220"automation vs customization\u8221" comes in: automation frames it as entering a whole new scripting environment; we frame it more as just an alternate UI that you can use.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab this is the heart of the gentle slope\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab backend APIs: terrible\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the best would be right inline with the GUI (cite Scotty, instrumental work) but this has its own problems\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab we settle for a compromise: an alternate structured view. (explicitly contrast this clearly)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab the CLI GUI thing\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Related Work\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Find a way to organize all this:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab our own workshop paper. since then\u8230?\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab fundamentally rearchitected around table adapters\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab evaluated on many more websites\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab more fully describing how the system works\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab browser extensions\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab instrumental interaction, Scotty, Webstrates\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab customization research tools: Chickenfoot, Coscripter\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Wildcard, like Chickenfoot, wants to hide HTML from users. But we show a structured data view, whereas Chickenfoot shows nothing\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab desktop customization: Applescript, VBA, COM\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab browser dev tools\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab database GUIs\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab spreadsheets\sa180\par}
}
