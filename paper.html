<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link href="https://fonts.googleapis.com/css?family=Merriweather:300,700" rel="stylesheet">
  <title>Customizing Software by Direct Manipulation of Tabular Data</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="draft.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>

<header id="title-block-header">
<h1 class="title">Customizing Software by Direct Manipulation of Tabular Data</h1>
</header>
<p>In this paper we show how the behavior of a software application can be extended and adapted by direct manipulation, using table-driven customization, a new paradigm that allows end users to customize applications without writing traditional code.</p>
<p>Instead, users directly manipulate a tabular view of the structured data inside the application—rather than writing imperative scripts (as in most customization tools). This simple model also accommodates a spreadsheet formula language and custom data editing widgets, which provide sufficient expressivity to implement many useful customizations.</p>
<p>We illustrate the approach with Wildcard, a browser extension that implements table-driven customization in the context of web applications. Through concrete examples, we show that our paradigm can be used to create useful customizations for real applications. We share reflections from experience using the Wildcard system, on both its strengths and limitations relative to other customization approaches. Finally, we explore how this paradigm might lead to new software architectures that encourage this form of customization.</p>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#sec:examples"><span class="toc-section-number">2</span> Examples</a></li>
<li><a href="#sec:architecture"><span class="toc-section-number">3</span> System architecture</a></li>
<li><a href="#sec:evaluation"><span class="toc-section-number">4</span> Evaluation</a></li>
<li><a href="#sec:themes"><span class="toc-section-number">5</span> Key themes</a></li>
<li><a href="#sec:related-work"><span class="toc-section-number">6</span> Related Work</a></li>
<li><a href="#conclusion"><span class="toc-section-number">7</span> Conclusion</a></li>
<li><a href="#bibliography">References</a></li>
</ul>
</nav>
<h1 data-number="1" id="introduction" data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Most attempts at empowering end users to customize their software offer a simplified version of programming. Some scripting languages <span class="citation" data-cites="bolin2005 cook2007">[<a href="#ref-bolin2005" role="doc-biblioref">6</a>,<a href="#ref-cook2007" role="doc-biblioref">9</a>]</span> have a friendly syntax that resembles natural language. Some visual customization tools eliminate text syntax entirely. Macro recorders <span class="citation" data-cites="cook2007 chasins2018 anupam2000">[<a href="#ref-anupam2000" role="doc-biblioref">3</a>,<a href="#ref-chasins2018" role="doc-biblioref">8</a>,<a href="#ref-cook2007" role="doc-biblioref">9</a>]</span> remove some of the initial programming burden by letting a user start with concrete demonstrations.</p>
<p>Despite their many differences, these approaches all share something in common: an imperative programming model, with statement sequencing, mutable variables and loops. End users express their ideas in scripts—sequences of commands—which, name aside, are not very different from conventional code.</p>
<p>We have known for decades about an alternate approach: <em>direct manipulation</em> <span class="citation" data-cites="shneiderman1983">[<a href="#ref-shneiderman1983" role="doc-biblioref">19</a>]</span>, where “visibility of the object of interest” replaces “complex command language syntax”. Direct manipulation is the <em>de facto</em> standard in GUIs today, but when it comes to customizing software, it is rarely to be found. In this work, we ask: what would it look like to build a software customization interface that relies on direct manipulation? We take inspiration from spreadsheets and visual database query interfaces <span class="citation" data-cites="2020a bakke2016">[<a href="#ref-bakke2016" role="doc-biblioref">4</a>,<a href="#ref-2020a" role="doc-biblioref">21</a>]</span>, which have successfully enabled end users to run queries and computations through direct manipulation of data.</p>
<p>In this paper we present a technique called <em>table-driven customization</em>, which applies ideas from visual query interfaces in the context of software customization. An application’s UI is augmented with a table view, where the user can see and manipulate the application’s internal data . Changes in the table view result in immediate corresponding changes to the original user interface of the application, enabling the user to customize an application with live feedback.</p>
<p>We have developed a browser extension called Wildcard which uses web scraping techniques to implement table-driven customization for existing Web applications. In Section 2, we introduce the key ideas of table-driven customization by presenting several examples of real customizations implemented in Wildcard.</p>
<p>In Section 3, we explain the architecture of table-driven customization. We focus on the <em>table adapter</em> abstraction, which allows many different types of underlying data to be bidirectionally mapped to a table. We describe several types of table adapters we’ve built in Wildcard, and also describe future adapters that are supported by the general paradigm.</p>
<p>We have used Wildcard to build real customizations for 11 different websites. In Section 4, we present reflections from this process, outlining the kinds of customizations we were able to build, limitations we encountered, and reflections on the ease of integrating scraping logic with real websites.</p>
<p>In Section 5, we discuss some key themes from our work:</p>
<ul>
<li><em>Customization by direct manipulation</em>: End users should be able to customize an application by directly examining and modifying its data, rather than by writing imperative scripts.</li>
<li><em>Wrapping applications for customization</em>: Typically, tools that don’t rely on official extension APIs resort to offering low-level APIs for customization. Instead, we propose a community-maintained library of semantic wrappers around existing applications, enabling end users to work with domain objects rather than low-level representations.</li>
</ul>
<p>Table-driven customization relates to existing work in many areas. In particular, our goals overlap with many software customization tools, and our methods overlap with direct manipulation interfaces for working with structured data, including visual database query systems and spreadsheets. We explore these connections and more in Section 6.</p>
<h1 data-number="2" id="sec:examples" data-number="2"><span class="header-section-number">2</span> Examples</h1>
<p><em>todo: maybe redo this as a separate example to avoid self plagiarism?</em></p>
<p>To concretely illustrate the end user experience of table-driven customization, here are several real examples of using the Wildcard browser extension to customize websites.</p>
<div class="html-only">
<figure>
<img src="media/airbnb-demo-300dpi.png" id="fig:airbnb-demo" alt="" /><figcaption>Figure 1: Using Wildcard to augment the Airbnb search page for booking accommodations</figcaption>
</figure>
</div>
<div class="pdf-only">

</div>
<h2 data-number="2.1" id="augmenting-search-results" data-number="2.1"><span class="header-section-number">2.1</span> Augmenting search results</h2>
<p>In 2012, the travel site Airbnb removed the ability to sort accommodation searches by price. Users could still filter by price range, but could no longer view the cheapest listings first. Many users complained that the change seemed hostile to users. “It’s so frustrating! What is the logic behind not having this function?” said one user on the <a href="https://community.withairbnb.com/t5/Hosting/Sorting-listing-by-price/td-p/559404">Airbnb support forum</a>. Alas, the feature remains missing to this day.</p>
<p>Using Wildcard, the user can fix this omission, while leaving the page’s design and the rest of its functionality unchanged.<span class="pdf-only"></span> First, the user opens up the Wildcard panel, which shows a table corresponding to the search results in the page. As they click around in the table, the corresponding row in the page is highlighted to indicate the mapping between the views.</p>
<p>Then, the user clicks on the price column header to sort the spreadsheet and the Airbnb UI by price<span class="pdf-only"></span>. They also filter to listings with a user rating above 4.5 (another feature missing in the original Airbnb UI).</p>
<p>After manipulating the data, the user closes the table view and continues using the website. Because the application’s UI usually has a nicer visual design than a spreadsheet, Wildcard does not aim to replace it—at any time, the user can use either the UI, the spreadsheet, or both together.</p>
<p>Many websites that show lists of data also offer actions on rows in the table, like adding an item to a shopping cart. Wildcard has the ability to make these “row actions” available in the data table through the site adapter. In the Airbnb UI, saving multiple listings to a Favorites list requires tediously clicking through them one by one. Using Wildcard row actions, the user can select multiple rows and favorite all of them with a single click<span class="pdf-only"></span>. Similarly, the user can open the detailed pages for many listings at once.</p>
<p>Next, the user wants to jot down some notes about each listing. To do this, they type some notes into an additional column in each row, and the notes appear inside the listings in the original UI<span class="pdf-only"></span>. The annotations are saved in the browser and associated with the backend ID of the listing, so they will appear in future browser sessions that display the same listing.</p>
<p>Wildcard also includes a formula language that enables more sophisticated customizations. When traveling without a car, it’s useful to evaluate potential places to stay based on how walkable the surroundings are. Using a formula, the user can integrate Airbnb with Walkscore, an API that rates the walkability of any location on a 1-100 scale. When the user calls the <code>walkscore</code> formula with the listing’s latitude and longitude as arguments, it returns the walk score for that location and shows it as the cell value. Because the cell’s contents are injected into the page, the score also appears in the UI<span class="pdf-only"></span>.</p>
<h2 data-number="2.2" id="snoozing-todos" data-number="2.2"><span class="header-section-number">2.2</span> Snoozing todos</h2>
<div class="html-only">
<figure>
<img src="media/todomvc-demo-300dpi.png" id="fig:todomvc-demo" alt="" /><figcaption>Figure 2: Using Wildcard to add a “snooze” feature to the TodoMVC todo list app</figcaption>
</figure>
</div>
<div class="pdf-only">

</div>
<p>In addition to fetching data from other sources, Wildcard formulas can also perform computations. In this example, the user would like to augment the TodoMVC todo list app with a “snooze” feature, which will temporarily hide a todo from the list until a certain date.<span class="pdf-only"></span></p>
<p>The user opens the table view, which shows the text and completed status of each todo. They start the customization by adding a new column to store the snooze date for each todo<span class="pdf-only"></span>.</p>
<p>The next step is to hide snoozed todos. The user creates a <code>snoozed?</code> column, which uses a formula to compute whether a todo is snoozed—i.e., whether it has a snooze date in the future<span class="pdf-only"></span>. Then, they simply filter the table to hide the snoozed todos<span class="pdf-only"></span>.</p>
<p>Because the built-in <code>NOW()</code> function always returns the current datetime, snoozed todos will automatically appear once their snooze date arrives.</p>
<p>Because this implementation of snoozing was built on the spreadsheet abstraction, it is completely decoupled from this particular todo list app. We envision that users could share these types of customizations as generic browser extensions, which could be applied to any site supported by Wildcard with no additional effort.</p>
<h2 data-number="2.3" id="adding-a-custom-datepicker" data-number="2.3"><span class="header-section-number">2.3</span> Adding a custom datepicker</h2>
<div class="html-only">
<figure>
<img src="media/expedia-demo-300dpi.png" id="fig:expedia-demo" alt="" /><figcaption>Figure 3: Using Wildcard to augment the Expedia page for booking a flight</figcaption>
</figure>
</div>
<div class="pdf-only">

</div>
<p>It might seem that Wildcard is only useful on websites that display lists of tabular data, but the table metaphor is flexible enough to represent many types of data. For example, a flight search form on Expedia can be represented as a single row, with a column corresponding to each input<span class="pdf-only"></span>.</p>
<p>In some of the previous examples, the table cells were read-only (because users can’t, for example, change the name or price of an Airbnb listing). In this case, the cells are writable, which means that changes in the table are reflected in the form inputs. This becomes especially useful when combined with GUI widgets that can edit the value of a table cell.</p>
<p>Filling in dates for a flight search often requires a cumbersome workflow: open up a separate calendar app, find the dates for the trip, and then carefully copy them into the form. In Wildcard, the user can avoid this by using a datepicker widget that shows the user’s personal calendar events<span class="pdf-only"></span>. The user can directly click on the correct date, and it gets inserted into both the spreadsheet and the original form.n</p>
<h1 data-number="3" id="sec:architecture" data-number="3"><span class="header-section-number">3</span> System architecture</h1>
<div class="html-only">
<figure>
<img src="media/table-adapter.svg" id="fig:table-adapter" alt="" /><figcaption>Figure 4: The table adapter architecture</figcaption>
</figure>
</div>
<div class="pdf-only">

</div>
<p>Figure 4 summarizes the overall architecture of table-driven customization, using a simplified version of the Airbnb example above. In this example, the name of each listing is scraped from the web page DOM, the latitude and longitude of each listing is scraped from AJAX responses, and user annotations are loaded from the brower’s local storage.</p>
<p>First, the three different data sources are each bidirectionally mapped to a table interface by a <strong>table adapter</strong>. The table adapter defines how to map a particular type of data to a table, and what effects edits should have on the original data source. In some cases, the mapping logic is straightforward: the local storage adapter stores a table of data, so the mapping to the table abstraction is trivial. In other cases, the mapping is more involved: the DOM scraping adapter implements web scraping logic to produce a table of data from the web page, and turns edits to the table into DOM manipulations like reordering rows of data on the page.</p>
<p>The three separate tables are then combined into a single table for the end user to view and edit. The <strong>query engine</strong> is responsible for creating this combined view, and routing the user’s edits back to the individual table adapters. In this example, the query engine has joined the three tables together by a shared ID column, and sorted the result by the name column.</p>
<p>We now examine each component of the system in more detail.</p>
<h2 data-number="3.1" id="table-adapters" data-number="3.1"><span class="header-section-number">3.1</span> Table adapters</h2>
<p>A key idea in table-driven customization is that a wide variety of data sources can be mapped to the generic abstraction of an editable table. In a relational database, the table matches the underlying storage format, but in table-driven customization, the table is merely an <em>interface layer</em>. The data shown in the table is a projection of some underlying state, and edits to the table can have complex effects on the underlying state.</p>
<p>Externally, a table adapter must satisfy an abstract interface. The first two parts of the interface resemble the interface exposed by a table in a relational database:</p>
<p><strong>Returning a table</strong>: A table adapter exposes a table of data: an ordered list of records. Each record carries a unique identifier and associates named attributes with values. Tables have a typed schema, so the same attributes are shared across all records. A table adapter can update the contents of a table at any time, in response to changes in the underlying state (e.g., a DOM scraping adapter can update the table when the page body changes). When data changes, the query view is reactively updated in response.</p>
<p><strong>Making edits</strong>: The query engine can issue a request to a table adapter to make an edit to a record. The meaning of making an edit can vary depending on the adapter: in the local storage adapter, an annotation may be persisted into local storage; in the DOM scraping adapter, an edit may represent filling in a form field. An adapter can also mark values as read-only if it wouldn’t be meaningful to edit them; for example, the DOM scraping adapter typically marks page content as read-only, except for editable form fields.</p>
<p>The query engine also sends additional information about the combined query view to each table adapter. These functions are currently used to provide the DOM scraping adapter with sufficient information to manipulate the original application UI as the user manipulates the table view.</p>
<p><strong>Sorting/filtering</strong>: When the user sorts or filters the query view, an ordered list of visible IDs is sent to each table adapter. The DOM scraping adapter uses this information to modify the list of visible rows in the web page.</p>
<p><strong>Information from other tables</strong>: The query engine sends each table adapter the entire combined table of data being rendered to the user. The DOM scraping adapter uses this to add annotations to the page by looking for additional data columns joined to scraped rows, and rendering them in the page.</p>
<p><strong>Currently selected record</strong>: The query engine notifies each table adapter about which record is currently selected by the user in the table UI. The DOM scraping adapter uses this information to highlight the row in the page that corresponds to the selected record in the table.</p>
<h3 data-number="3.1.1" id="types-of-table-adapters" data-number="3.1.1"><span class="header-section-number">3.1.1</span> Types of table adapters</h3>
<p>Here we describe in more detail the table adapters that we have implemented in Wildcard to power the customizations shown in Section 2.</p>
<p><strong>DOM scraping adapters</strong> are the essential component that enables Wildcard to interface with an existing website UI. In addition to the standard web scraping problem of extracting a table of data from the DOM, a scraping adapter must also manipulate the DOM to reorder rows, edit form entries, and inject annotations as the table is edited.</p>
<p>Because each website has unique content, we rely on programmers to create a DOM scraping adapter for each individual website to make it available for customization in Wildcard. To make this approach viable, we have built a library of functions that make it easy to implement a scraping adapter, requiring the programmer only to implement the minimal site-specific parts. The programmer writes a single Javascript function which can use standard scraping techniques like CSS selectors and DOM APIs to extract relevant elements from the page. The library functions then wrap this function to implement the rest of the needed functionality; for example, when the table is sorted, we find the DOM elements corresponding to the rows in the table, remove them from the page, and then reinsert them in the new order.</p>
<p>An <strong>AJAX scraping adapter</strong> intercepts AJAX requests made by a web page, and extracts information from those requests. When available, this tends to be a helpful technique because the data is already in a structured form, and often includes information not shown in the UI. As with DOM scraping adapters, we have made it easy for programmers to create site-specific AJAX scraping adapters. A programmer writes a function that specifies how to extract data from an AJAX request, and the framework handles the details of intercepting requests and calling the programmer-defined function.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The <strong>local storage adapter</strong> simply stores a table of data in the browser. As shown in the example use cases, this can be useful for persisting annotations in a private way, without uploading them to a web service.</p>
<h3 data-number="3.1.2" id="future-adapters" data-number="3.1.2"><span class="header-section-number">3.1.2</span> Future Adapters</h3>
<p>We have designed the table adapter API to be general enough to support other types of useful adapters in the future. Here are two such possibilities:</p>
<p><strong>Integrated website adapters</strong>: A key benefit of the table adapter abstraction is that Wildcard is not coupled to web scraping as the only means for integrating with existing sites, but can also accommodate first party developers adding support directly into their own websites. An “integrated website adapter” installed by the developer could directly accesses the internal state of the application, providing the same functionality as a DOM scraping adapter but in a more robust way.</p>
<p>With the advent of rich frontend web frameworks, structured application state is now often available in the web client. We suspect it is possible to create plugins for frontend frameworks that expose this state to Wildcard with only minimal effort from the application developers. To test this hypothesis, we have created an early prototype of a Wildcard adapter for the Redux state management library, and used it with the TodoMVC todo list application. To install the adapter, the programmer only needs to make a few small changes to their app:</p>
<p><em>Exposing a table</em>: In Redux, app developers already represent the state of a user interface as a single object. To expose a table of data, the developer simply writes a function that maps the state object to a table. <em>Editing data values</em>: The developer defines how edits to records in the table should map to edits in the state object. <em>Sorting/filtering the UI</em>: The developer inserts an additional data processing step before the state object is rendered in the UI, so that Wildcard can apply sorting and filtering. <em>Annotations</em>: The developer adds additional React components managed by Wildcard into their UI tree, which render additional data as annotations.</p>
<p>In certain types of software, customizability is often touted as a key selling point. An integrated website adapter would provide a way for developers to integrate with an existing ecosystem of formulas and customization tools, without needing to build all that functionality from scratch.</p>
<p><strong>Shared storage adapter</strong>: It would be useful to share user annotations among users and across devices—for example, collaboratively taking notes with friends on options for places to stay on Airbnb. The existing Local Storage Adapter could be extended to share live synchronized data with other users. This could be achieved through a centralized web server, or through P2P connections that might provide stronger privacy guarantees.</p>
<h2 data-number="3.2" id="query-engine" data-number="3.2"><span class="header-section-number">3.2</span> Query engine</h2>
<p>The query engine is responsible for coordinating across multiple table adapters. It joins data across multiple tables and creates a single result table which is shown to the user through the editor. It also handles all user interactions and routes appropriate messages to each table adapter.</p>
<p>Queries are processed in three steps. First, the query invokes a primary DOM scraping table adapter that associates records in the result with elements in the application’s user interface. At minimum, the primary table adapter needs to return record IDs and have the ability to manipulate the application’s UI. It can also optionally return data about each record. Next, additional tables (AJAX data, local storage data) are left-joined by ID. Finally, the result table can be sorted and filtered by any column.</p>
<p>This query model can be viewed as a tiny (and rather constrained) subset of the SQL query model. Despite its simplicity, this simple model has proven sufficient for meeting the needs of customization in practice, and minimizes the complexity of supporting more general and arbitrary queries. But because it fits into the general paradigm of relational queries, it could theoretically be extended to support a wider range of queries.</p>
<p>The query engine is also responsible for executing formulas. We have built a small formula language resembling the ones used in visual query tools like SIEUFERD. As in those tools, and unlike in spreadsheets, formulas automatically apply across an entire column of data, and reference other column names instead of values on specific rows. For example, the user would write <code>=price * 2</code> to create a column with a value derived from a price attribute. This is more convenient than needing to copy-paste a formula across an entire column as in spreadsheets, and none of our customization use cases have uncovered a need for writing different formulas on different rows of the table.</p>
<h2 data-number="3.3" id="table-editor" data-number="3.3"><span class="header-section-number">3.3</span> Table editor</h2>
<p>In Wildcard we provide a basic table editor as the user interface on top of the query engine. It is built with the Handsontable Javascript library, which provides UI elements for viewing and editing a table, as well as basic query operations like sorting and filtering.</p>
<p><em>todo: other table instruments</em></p>
<div class="pdf-only">

</div>
<h1 data-number="4" id="sec:evaluation" data-number="4"><span class="header-section-number">4</span> Evaluation</h1>
<div class="html-only">
<p>todo: fill in this table</p>
</div>
<p>To evaluate table-driven customization in practice, we built the Wildcard browser extension, which implements table-driven customization in the context of existing websites. It is built in Typescript, and works across three major browsers: Chrome, Firefox, and Edge.</p>
<p>We have used Wildcard to customize 11 websites, including transactional sites like Amazon and Uber Eats, and media consumption sites like Hacker News and Youtube. Table 1 summarizes all these customizations, including the number of lines of code in the adapter configuration for each site.</p>
<p>So far, most usage of Wildcard has come from members of the project team. Here we offer our reflections on using the system, focused on two key questions:</p>
<ul>
<li>How broad is the range of possible customizations in this paradigm?</li>
<li>How feasible is it to build DOM scraping adapters for real websites, in practice?</li>
</ul>
<h2 data-number="4.1" id="range-of-customizations" data-number="4.1"><span class="header-section-number">4.1</span> Range of customizations</h2>
<p>We have found that table-driven customization can serve a broad range of useful purposes. Here we expand on some examples that illuminate various aspects of using the system in practice.</p>
<h3 data-number="4.1.1" id="sortingfiltering" data-number="4.1.1"><span class="header-section-number">4.1.1</span> Sorting/filtering</h3>
<p>It might seem that most websites already have adequate sorting and filtering functionality, but we have found it surprisingly helpful to add new sorting/filtering functionality to websites using Wildcard.</p>
<p>Sometimes, websites have opaque algorithms which they use to rank results, which presumably maximize profit but don’t offer much control to the user. For example, Airbnb doesn’t allow users to sort listings by price, and Youtube doesn’t allow users to sort the homepage by watch time. Wildcard enables users to take back some control over this process.</p>
<p>In other cases we have found that a lack of sorting options seems less intentional, and simply a missing feature. For example, the Instacart grocery delivery service doesn’t allow users to sort their grocery cart by price or category. Our guess is that they simply haven’t gotten around to implementing the feature yet.</p>
<p>In the current implementation of Wildcard, users can only sort and filter entries which are shown on the current page, which means that users are not entirely liberated from the suggestions of the opaque algorithm. We could work around this restriction in the future by fetching content across multiple pages, but we’ve also found that sorting/filtering a single page of a paginated list is often an acceptable outcome, and even a preferable one. For example, it’s more useful to sort 30 recommended Youtube videos than to try to sort all videos on Youtube; similarly it’s convenient to view the Hacker News front page sorted by read time, rather than all Hacker News articles.</p>
<h3 data-number="4.1.2" id="annotating" data-number="4.1.2"><span class="header-section-number">4.1.2</span> Annotating</h3>
<p>Many other web annotation systems focus on annotating text or arbitrary webpage content, but Wildcard only allows for annotating structured objects extracted by an adapter, which results in quite a different set of use cases.</p>
<p>Annotating with Wildcard has proven most useful when taking notes on a list of possible options: e.g., evaluating possible Airbnb locations to rent. We have also used it with Instacart’s online grocery cart, for jotting down notes like “should we get more milk?”</p>
<h3 data-number="4.1.3" id="formulas" data-number="4.1.3"><span class="header-section-number">4.1.3</span> Formulas</h3>
<p>Formulas are the most powerful part of the Wildcard system. So far, we have only built a small number of functions into the language, but by adding more functions, the fundamental computing model could support a very broad range of useful computations, as shown by the success of spreadsheets.</p>
<p>We have found that formulas are useful for fetching data from Web APIs. We’ve used them to augment Airbnb listings with walkability scores, and augment Hacker News articles with estimated read times. One challenge of the current language design is that supporting each web API requires adding a new function to the language using code, because web APIs typically return complex JSON data structures which don’t make sense to display in a single table cell. Adding functions for handling JSON data to the formula language might help resolve this.</p>
<p>We have also found instances where simple data manipulation is useful: adding together different subtotals into a total price, or manipulating the results of a formula expression with arithmetic or concatenating string labels, as shown in the example in Section 2. (<em>todo: this makes sense iff we switch the examples sectino to HN</em>)</p>
<h3 data-number="4.1.4" id="cell-editors" data-number="4.1.4"><span class="header-section-number">4.1.4</span> Cell editors</h3>
<p>(<em>note: written with the assumption that Expedia gets cut from the Examples section</em>)</p>
<p>“Cell editors” are UI widgets that expose a custom editing UI for a single cell of the table view. A programmer building a cell editor only needs to integrate it with the table viewer; actually propagating values into the website UI is handled by the site-specific DOM adapter. As a result, creating a new cell editor can be as easy as just creating glue code between the table editor and an existing UI widget library.</p>
<p>One benefit of cell editors is that a user can use their personal information in a web UI without uploading it to the website. To explore this idea, we created a cell editor based on the FullCalendar Javascript plugin, which can load data from a Google Calendar. This makes it convenient to enter dates into a website based on the user’s personal calendar information.</p>
<p>Another benefit of cell editors is that a user can choose their preferred widget for editing some type of information. We built a cell editor based on the CKEditor rich text editor. As an example of using this editor, we integrated it with the Blogger website and used it to edit blog posts, in place of the Blogger website’s built-in editor.</p>
<h3 data-number="4.1.5" id="limitations" data-number="4.1.5"><span class="header-section-number">4.1.5</span> Limitations</h3>
<p>There are many useful customizations which are not possible in the table-driven customization paradigm. Wildcard can only make customizations that use the available data exposed in the table. UI modifications are limited in scope; for example, deleting arbitrary buttons isn’t possible. At one point, we wanted to build an automation to repeatedly load a grocery delivery website to check for open delivery slots, but it wasn’t clear how to achieve this. Some of these limitations are specific to the current implementation of the Wildcard extension, but some are more general to the entire idea of table-driven customization.</p>
<p>We consider this an acceptable outcome—our goal is simply to make many useful customizations available to end users with a low threshold, not to span all possible customizations. Section 5.1 discusses this point further.</p>
<p>One benefit of Wildcard is <em>predictability</em>: once we built a site adapter for a website, it was generally obvious to us what types of customizations were and weren’t possible, and the UI guided us towards building customizations that matched the system’s model. For example, it’s clear that it’s not possible to customize a website using data not available in the table.</p>
<h2 data-number="4.2" id="viability-of-dom-scraping" data-number="4.2"><span class="header-section-number">4.2</span> Viability of DOM scraping</h2>
<p>Our second evaluation area is less about the conceptual approach of table-driven customization, and more about our specific implementation of customizing existing web applications. In order for third-party customization through Wildcard to succeed, it is important that creating usable adapters for existing websites takes minimal effort.</p>
<p>Most of our DOM scraping adapters were created by members of our team. However, an external developer unaffiliated with the project contributed one adapter, designed to sort the Github page listing a user’s repositories. They described the experience as “very straightforward.”</p>
<p>The adapters for our test sites ranged from 36 to 117 lines of code, averaging 68 lines; Table 1 shows the full lines of code for each adapter.</p>
<p>Some of the challenges of writing a DOM scraping adapter are the same ones as with writing normal web scraping code, but the more interactive nature of Wildcard introduces additional challenges. rve changes, but it may prove challenging to observe changes on some sites only through the DOM. One challenge is triggering updates to the spreadsheet data in response to UI changes that happen after initial page load. Site adapters are responsible for recognizing these changes by observing the DOM. So far, we have been able to use event listeners and the MutationObserver API to successfully obse</p>
<p>Another challenge is persisting updates to the DOM—some websites use virtual DOM frameworks that can occasionally overwrite changes made by Wildcard.</p>
<p>So far, we’ve managed to work around these issues for all the websites we’ve tried, but we don’t claim that any website can be customized through DOM scraping. As web frontend code gets increasingly complex (and starts to move beyond the DOM to other technologies like Shadow DOM or even WebGL for rendering), it may become increasingly difficult to customize websites from the outside without first-party support.</p>
<h1 data-number="5" id="sec:themes" data-number="5"><span class="header-section-number">5</span> Key themes</h1>
<h2 data-number="5.1" id="sec:dm" data-number="5.1"><span class="header-section-number">5.1</span> Customization by direct manipulation</h2>
<p>Hutchins, Hollan and Norman <span class="citation" data-cites="hutchins1985">[<a href="#ref-hutchins1985" role="doc-biblioref">12</a>]</span> describe a direct manipulation interface as one that uses a model-world metaphor, rather than a conversation metaphor. Rather than conversing with the system about an assumed world, “the world is explicitly represented” and the user can “[act] upon the objects of the task domain themselves.”</p>
<p>Most GUIs today employ direct manipulation, but software customization tools typically use an imperative programming model, which implements the conversational metaphor rather than direct manipulation. For example, in Applescript <span class="citation" data-cites="cook2007">[<a href="#ref-cook2007" role="doc-biblioref">9</a>]</span>, the scripting language for customizing Mac OS applications, here is how a user retrieves a list of of calendar names from the Calendar application:</p>
<pre><code>tell application &quot;Calendar&quot;
  name of calendars
end tell</code></pre>
<p>Some customization environments (Automator for Mac, Shortcuts for iOS, Zapier for web APIs) forego text syntax and enable the user to connect programs and construct automations by dragging and dropping commands. These environments still do not constitute direct manipulation, though: the objects being manipulated are in the domain of programming, not the domain of the task at hand.</p>
<p>Imperative programming is a reasonable choice as the model for building customizations. Turing-complete programming provides a high ceiling for possible customizations, and a sequence of commands is a natural fit for automations which simulate a series of steps taken by the user.</p>
<p>However, there is a serious drawback to this approach. MacLean et al <span class="citation" data-cites="maclean1990">[<a href="#ref-maclean1990" role="doc-biblioref">17</a>]</span> describe an ideal for user-tailorable systems: a “gentle slope” from using to customizing, where small incremental increases in skill lead to corresponding increments of customization power. Requiring users to learn programming for customization creates an abrupt “cliff,” where a significant learning investment is required even to implement simple customizations. Another goal of MacLean et al is that “it should be as easy to change the environment as it is to use it,” at least for some subset of changes. In scripting languages, even user-friendly ones like Applescript or Chickenfoot, the experience of customization does not remotely resemble the experience of use, so these systems can’t meet this goal.</p>
<p>With table-driven customization we aim to provide a gentler slope, by using direct manipulation for software customization. The data shown in the table view is the domain data from the original application. The user makes changes to the data by selecting areas of interest in the table, e.g. sorting/filtering by clicking the relevant column header, or adding annotation by clicking on the relevant row. These interactions are common in GUI applications, and Wildcard therefore meets MacLean et al’s goal: some one-click customizations are as easy as using the original application.</p>
<p>One aspect of directness which we have chosen not to maintain in Wildcard is enabling customization in the context of the original user interface, as explored by some other tools like Scotty <span class="citation" data-cites="eagan2011">[<a href="#ref-eagan2011" role="doc-biblioref">10</a>]</span>. We have found that augmenting the original UI with an additional structured representation has numerous benefits. It provides a consistent experience across all applications, and clearly shows the user what structured data is available to work with.</p>
<p>Ainsworth et al provide a helpful taxonomy of the value of multiple representations <span class="citation" data-cites="ainsworth1999">[<a href="#ref-ainsworth1999" role="doc-biblioref">1</a>]</span>. In their terms, Wildcard plays a <em>complementary role</em> by supporting a different set of tasks from the original application, while displaying <em>shared information</em>. We also suspect that Wildcard helps <em>constructs deeper understanding</em> by <em>subtraction</em>. By stripping away details and only showing the essential data in an interface, Wildcard helps users think of new ways of using that data, outside the specific constraints of the original application.</p>
<p>It is important to note that there are many specific customizations that can be achieved in systems like Chickenfoot <span class="citation" data-cites="bolin2005">[<a href="#ref-bolin2005" role="doc-biblioref">6</a>]</span> that cannot be reproduced in Wildcard. We consider this an acceptable tradeoff in exchange for achieving a gentler slope of customization, and we show in Section 2 and Section 4 that our model can still implement many useful customizations in practice. Also, there is sometimes a way to reframe an imperative script in terms of our direct manipulation model; for example, a script that iterates through rows in a page adding some additional information could be reproduced using a formula in Wildcard.</p>
<h2 data-number="5.2" id="wrapping-applications-for-customization" data-number="5.2"><span class="header-section-number">5.2</span> Wrapping applications for customization</h2>
<p>Software customization tools typically fall into one of two categories: third-party, or semantic.</p>
<p><em>Ad hoc customization tools</em> enable customization without using official extension APIs, enabling a broader range of customizations on top of more applications. For example, web browser extensions have demonstrated the utility of customizing websites through manipulating the DOM, without needing explicit extension APIs to be built in. However, ad hoc customization comes with a corresponding cost: these tools can typically only operate at a low level of abstraction, e.g. manipulating user interface elements. This makes it harder for end users to write scripts, and makes the resulting scripts more brittle.</p>
<p><em>Anticipated customization tools</em>, in contrast, use explicit extension APIs provided by the application developer. Examples of this include accessing a backend web API, or writing a customization in Applescript that uses an application-specific API. The main benefit is that this allows the extension author to work with meaningful concepts in the application domain—“create a new calendar event” rather than “click the button that says new event.”—which makes customizations easier to build and more robust. However, this style limits the range of extensions that can be built to those that the official plugin API supports.</p>
<p>With Wildcard, we use a hybrid approach that aims to provide the best of both worlds. Programmers implement an API wrapper that is internally implemented as an ad hoc customization, but externally provides a high-level interface to the application, abstracting away the details of the user interface. These wrappers are added to a shared repository, available to all users of the system. When an end user is using a site that already has an adapter, they get a semantic customization experience that avoids low-level details.</p>
<p>One way to view this approach is as introducing a new abstraction barrier into third-party extension. Typically, a third party customization script combines two responsibilities: 1) mapping the low-level details of a user interface to semantic constructs (e.g., using CSS selectors to find certain page elements), and 2) handling the actual logic of the specific customization. Even though the mapping logic is often more generic than the specific customization, the intertwining of these two responsibilities in a single script makes it very difficult to share the mapping logic across scripts.</p>
<p>With Wildcard we propose a decoupling of these two layers: a repository of shared wrappers maintained by programmers, and a separate repository of specific customizations built on top of these wrappers. This general architecture has been successfully demonstrated by projects like Gmail.js, an open source project that creates a convenient API for browser extensions to interface with the Gmail web email client.</p>
<p>(<em>todo: mention automated wrapper induction here or somewhere else?</em>)</p>
<h1 data-number="6" id="sec:related-work" data-number="6"><span class="header-section-number">6</span> Related Work</h1>
<p>This paper extends work reported in a workshop paper by Litt and Jackson <span class="citation" data-cites="litt2020">[<a href="#ref-litt2020" role="doc-biblioref">15</a>]</span> which presented an early prototype version of Wildcard. We have substantially extended their work in this paper by creating the table adapter abstraction and reimplementing the system around that abstraction, evaluating the system more fully on many more websites, and by characterizing the design of the system in more detail.</p>
<p>Table-driven customization relates to two broad areas of related work. Our problem statement is related to software customization tools, and our solution approach is related to spreadsheets and other direct manipulation interfaces.</p>
<h2 data-number="6.1" id="customization-tools" data-number="6.1"><span class="header-section-number">6.1</span> Customization tools</h2>
<p>Table-driven customization is most closely related to other tools that aim to empower end users to customize software without doing any programming.</p>
<p>This lineage goes back at least to the Buttons system by MacLean et al <span class="citation" data-cites="maclean1990">[<a href="#ref-maclean1990" role="doc-biblioref">17</a>]</span>, where Xerox Lisp users could share buttons that performed various “tailoring” actions on the system. The authors proposed the “gentle slope” idea which has greatly influenced our approach to table-driven customization (as discussed in Section 5.1). The authors also point out the importance of a “tailoring culture” where people with different skillsets collaborate to produce useful customizations; in their system, Lisp programmers create buttons that others can use, modify, and rearrange. This division of labor corresponds to our idea of semantic wrappers, where end user customization is supported by programmer-created building blocks.</p>
<p>Some recent web customization tools aim to enable end users to modify web interfaces without programming.</p>
<p>Sifter <span class="citation" data-cites="huynh2006">[<a href="#ref-huynh2006" role="doc-biblioref">13</a>]</span> enables end users to sort and filter lists of data based on web scraping, much like Wildcard’s sorting features. The main difference between the systems is that table-driven customization has many other use cases besides sorting and filtering. Also, Sifter involves end users in a semi-automated data extraction process, rather than having programmers create wrappers. This provides coverage of more websites, but at the expense of complicating the end user experience. We might explore such techniques in Wildcard in the future, but we think that it’s valuable for end users to have a customization experience free of web scraping details on supported websites. Finally Sifter implements scraping across multiple pages, a valuable feature for sorting and filtering which isn’t present in Wildcard.</p>
<p>Thresher <span class="citation" data-cites="hogue2005">[<a href="#ref-hogue2005" role="doc-biblioref">11</a>]</span> enables end users to create wrappers which map website content to Semantic Web schemas, making customizations available using the schema information. We share the general idea of wrappers with Thresher, but we have chosen to map to a single generic data type, rather than more specific schemas, which increases the range of websites and data supported by the system.</p>
<p>There are many software customization tools that offer simplified versions of programming for end users. Chickenfoot <span class="citation" data-cites="bolin2005">[<a href="#ref-bolin2005" role="doc-biblioref">6</a>]</span> and Coscripter <span class="citation" data-cites="leshed2008">[<a href="#ref-leshed2008" role="doc-biblioref">14</a>]</span> offer friendly syntax for writing web automation scripts; Applescript <span class="citation" data-cites="cook2007">[<a href="#ref-cook2007" role="doc-biblioref">9</a>]</span> attempts a similar goal for desktop customization. There are visual programming environments for customization which don’t involve writing any text: as a few examples, <a href="https://support.apple.com/guide/automator/welcome/mac">Automator</a> for Mac and <a href="https://apps.apple.com/us/app/shortcuts/id915249334">Shortcuts</a> for iOS are modern options for customizing Apple products, and <a href="https://zapier.com/">Zapier</a> enables users to connect different web applications together visually. As mentioned previously, these tools all require writing imperative programs in some form; we take a fundamentally different approach in table-driven customization.</p>
<h2 data-number="6.2" id="direct-manipulation-programming-interfaces." data-number="6.2"><span class="header-section-number">6.2</span> Direct manipulation programming interfaces.</h2>
<p>Another relevant area of literature is direct manipulation interfaces for interacting with structured data. We take much inspiration from these tools in our work, but apply them in a different domain: customizing existing software applications, rather than interacting with databases or constructing software from scratch.</p>
<p>The most closely related work is in systems that offer spreadsheet-like querying of relational data, as proposed by Liu and Jagadish <span class="citation" data-cites="liu2009">[<a href="#ref-liu2009" role="doc-biblioref">16</a>]</span>. SIEUFERD by Bakke and Karger <span class="citation" data-cites="bakke2016">[<a href="#ref-bakke2016" role="doc-biblioref">4</a>]</span> is an example; their paper presents a survey of various other similar tools. Our work is particularly influenced by the authors’ observation that direct manipulation requires that the user manipulate the <em>results</em> of a database query rather than the query itself, and that the user must see intermediate results at every step of constructing a computation. SIEUFERD’s interface supports a far wider range of possible queries than Wildcard, but the basic ideas of the user interface are similar.</p>
<p><a href="https://airtable.com/">Airtable</a> is another example of a modern commercial product that offers spreadsheet-like interaction with a relational database.</p>
<p>Our work is also inspired by the many projects which have explored using spreadsheets as a foundation for building software applications, including Object Spreadsheets <span class="citation" data-cites="mccutchen2016">[<a href="#ref-mccutchen2016" role="doc-biblioref">18</a>]</span>, Quilt <span class="citation" data-cites="benson2014">[<a href="#ref-benson2014" role="doc-biblioref">5</a>]</span>, Gneiss <span class="citation" data-cites="chang2014">[<a href="#ref-chang2014" role="doc-biblioref">7</a>]</span>, Marmite <span class="citation" data-cites="wong2007">[<a href="#ref-wong2007" role="doc-biblioref">20</a>]</span>, <a href="https://www.glideapps.com/">Glide</a>. These projects share the idea that a spreadsheet is a convenient interface for editing the data underlying a GUI application. We share that idea, but apply it to software customization, rather than building software from scratch.</p>
<p>Another system in this space is ScrAPIr, by Alrashed et al. <span class="citation" data-cites="alrashed2020">[<a href="#ref-alrashed2020" role="doc-biblioref">2</a>]</span>, which enables end users to access backend web APIs without programming. ScrAPIr shares a high level goal of end user empowerment, and also shares the idea of wrappers, by creating a shared library of wrappers around existing web APIs. However, unlike Wildcard, ScrAPIr targets explicit APIs exposed by developers, and also doesn’t aim to extend the frontend interfaces of web applications.</p>
<h1 data-number="7" id="conclusion" data-number="7"><span class="header-section-number">7</span> Conclusion</h1>
<p><em>todo</em></p>
<h1 class="unnumbered" data-number="" id="bibliography" class="unnumbered" data-number="">References</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-ainsworth1999">
<p>[1] Shaaron Ainsworth. 1999. The functions of multiple representations. <em>Computers &amp; Education</em> 33, 2-3 (September 1999), 131–152. DOI:<a href="https://doi.org/10.1016/S0360-1315(99)00029-9">https://doi.org/10.1016/S0360-1315(99)00029-9</a></p>
</div>
<div id="ref-alrashed2020">
<p>[2] Tarfah Alrashed, Jumana Almahmoud, Amy X. Zhang, and David R. Karger. 2020. ScrAPIr: Making Web Data APIs Accessible to End Users. In <em>Proceedings of the 2020 CHI Conference on Human Factors in Computing Systems</em> (CHI ’20), Association for Computing Machinery, Honolulu, HI, USA, 1–12. DOI:<a href="https://doi.org/10.1145/3313831.3376691">https://doi.org/10.1145/3313831.3376691</a></p>
</div>
<div id="ref-anupam2000">
<p>[3] Vinod Anupam, Juliana Freire, Bharat Kumar, and Daniel Lieuwen. 2000. Automating Web navigation with the WebVCR. <em>Computer Networks</em> 33, 1 (June 2000), 503–517. DOI:<a href="https://doi.org/10.1016/S1389-1286(00)00073-6">https://doi.org/10.1016/S1389-1286(00)00073-6</a></p>
</div>
<div id="ref-bakke2016">
<p>[4] Eirik Bakke and David R. Karger. 2016. Expressive Query Construction through Direct Manipulation of Nested Relational Results. In <em>Proceedings of the 2016 International Conference on Management of Data - SIGMOD ’16</em>, ACM Press, San Francisco, California, USA, 1377–1392. DOI:<a href="https://doi.org/10.1145/2882903.2915210">https://doi.org/10.1145/2882903.2915210</a></p>
</div>
<div id="ref-benson2014">
<p>[5] Edward Benson, Amy X. Zhang, and David R. Karger. 2014. Spreadsheet driven web applications. In <em>Proceedings of the 27th annual ACM symposium on User interface software and technology - UIST ’14</em>, ACM Press, Honolulu, Hawaii, USA, 97–106. DOI:<a href="https://doi.org/10.1145/2642918.2647387">https://doi.org/10.1145/2642918.2647387</a></p>
</div>
<div id="ref-bolin2005">
<p>[6] Michael Bolin, Matthew Webber, Philip Rha, Tom Wilson, and Robert C. Miller. 2005. Automation and customization of rendered web pages. In <em>Proceedings of the 18th annual ACM symposium on User interface software and technology - UIST ’05</em>, ACM Press, Seattle, WA, USA, 163. DOI:<a href="https://doi.org/10.1145/1095034.1095062">https://doi.org/10.1145/1095034.1095062</a></p>
</div>
<div id="ref-chang2014">
<p>[7] Kerry Shih-Ping Chang and Brad A. Myers. 2014. Creating interactive web data applications with spreadsheets. In <em>Proceedings of the 27th annual ACM symposium on User interface software and technology - UIST ’14</em>, ACM Press, Honolulu, Hawaii, USA, 87–96. DOI:<a href="https://doi.org/10.1145/2642918.2647371">https://doi.org/10.1145/2642918.2647371</a></p>
</div>
<div id="ref-chasins2018">
<p>[8] Sarah E. Chasins, Maria Mueller, and Rastislav Bodik. 2018. Rousillon: Scraping Distributed Hierarchical Web Data. In <em>The 31st Annual ACM Symposium on User Interface Software and Technology - UIST ’18</em>, ACM Press, Berlin, Germany, 963–975. DOI:<a href="https://doi.org/10.1145/3242587.3242661">https://doi.org/10.1145/3242587.3242661</a></p>
</div>
<div id="ref-cook2007">
<p>[9] William R. Cook. 2007. AppleScript. In <em>Proceedings of the third ACM SIGPLAN conference on History of programming languages - HOPL III</em>, ACM Press, San Diego, California, 1–1–1–21. DOI:<a href="https://doi.org/10.1145/1238844.1238845">https://doi.org/10.1145/1238844.1238845</a></p>
</div>
<div id="ref-eagan2011">
<p>[10] James R. Eagan, Michel Beaudouin-Lafon, and Wendy E. Mackay. 2011. Cracking the cocoa nut: User interface programming at runtime. In <em>Proceedings of the 24th annual ACM symposium on User interface software and technology - UIST ’11</em>, ACM Press, Santa Barbara, California, USA, 225. DOI:<a href="https://doi.org/10.1145/2047196.2047226">https://doi.org/10.1145/2047196.2047226</a></p>
</div>
<div id="ref-hogue2005">
<p>[11] Andrew Hogue and David Karger. 2005. Thresher: Automating the unwrapping of semantic content from the World Wide Web. In <em>Proceedings of the 14th international conference on World Wide Web - WWW ’05</em>, ACM Press, Chiba, Japan, 86. DOI:<a href="https://doi.org/10.1145/1060745.1060762">https://doi.org/10.1145/1060745.1060762</a></p>
</div>
<div id="ref-hutchins1985">
<p>[12] Edwin L Hutchins, James D Hollan, and Donald A Norman. 1985. Direct Manipulation Interfaces. (1985), 28.</p>
</div>
<div id="ref-huynh2006">
<p>[13] David F. Huynh, Robert C. Miller, and David R. Karger. 2006. Enabling web browsers to augment web sites’ filtering and sorting functionalities. In <em>Proceedings of the 19th annual ACM symposium on User interface software and technology - UIST ’06</em>, ACM Press, Montreux, Switzerland, 125. DOI:<a href="https://doi.org/10.1145/1166253.1166274">https://doi.org/10.1145/1166253.1166274</a></p>
</div>
<div id="ref-leshed2008">
<p>[14] Gilly Leshed, Eben M. Haber, Tara Matthews, and Tessa Lau. 2008. CoScripter: Automating &amp; Sharing How-to Knowledge in the Enterprise. In <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em> (CHI ’08), ACM, Florence, Italy, 1719–1728. DOI:<a href="https://doi.org/10.1145/1357054.1357323">https://doi.org/10.1145/1357054.1357323</a></p>
</div>
<div id="ref-litt2020">
<p>[15] Geoffrey Litt and Daniel Jackson. 2020. Wildcard: Spreadsheet-Driven Customization of Web Applications. In <em>Companion Proceedings of the 4th In- ternational Conference on the Art, Science, and Engineering of Programming</em>, Association for Computing Machinery, Porto, Portugal., 10. DOI:<a href="https://doi.org/10.1145/3397537.3397541">https://doi.org/10.1145/3397537.3397541</a></p>
</div>
<div id="ref-liu2009">
<p>[16] Bin Liu and H. V. Jagadish. 2009. A Spreadsheet Algebra for a Direct Data Manipulation Query Interface. In <em>2009 IEEE 25th International Conference on Data Engineering</em>, 417–428. DOI:<a href="https://doi.org/10.1109/ICDE.2009.34">https://doi.org/10.1109/ICDE.2009.34</a></p>
</div>
<div id="ref-maclean1990">
<p>[17] Allan MacLean, Kathleen Carter, Lennart Lövstrand, and Thomas Moran. 1990. User-tailorable systems: Pressing the issues with buttons. In <em>Proceedings of the SIGCHI conference on Human factors in computing systems Empowering people - CHI ’90</em>, ACM Press, Seattle, Washington, United States, 175–182. DOI:<a href="https://doi.org/10.1145/97243.97271">https://doi.org/10.1145/97243.97271</a></p>
</div>
<div id="ref-mccutchen2016">
<p>[18] Matt McCutchen, Shachar Itzhaky, and Daniel Jackson. 2016. Object spreadsheets: A new computational model for end-user development of data-centric web applications. In <em>Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software - Onward! 2016</em>, ACM Press, Amsterdam, Netherlands, 112–127. DOI:<a href="https://doi.org/10.1145/2986012.2986018">https://doi.org/10.1145/2986012.2986018</a></p>
</div>
<div id="ref-shneiderman1983">
<p>[19] B. Shneiderman. 1983. Direct Manipulation: A Step Beyond Programming Languages. <em>Computer</em> 16, 8 (August 1983), 57–69. DOI:<a href="https://doi.org/10.1109/MC.1983.1654471">https://doi.org/10.1109/MC.1983.1654471</a></p>
</div>
<div id="ref-wong2007">
<p>[20] Jeffrey Wong and Jason I. Hong. 2007. Making mashups with marmite: Towards end-user programming for the web. In <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems - CHI ’07</em>, ACM Press, San Jose, California, USA, 1435–1444. DOI:<a href="https://doi.org/10.1145/1240624.1240842">https://doi.org/10.1145/1240624.1240842</a></p>
</div>
<div id="ref-2020a">
<p>[21] 2020. Airtable. Retrieved January 3, 2020 from <a href="https://airtable.com">https://airtable.com</a></p>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>So far we have only implemented AJAX scraping in the Firefox version of Wildcard, since Firefox has convenient APIs for intercepting requests. It appears possible to implement in Chrome as well, but we have not finished our implementation.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-38867184-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
