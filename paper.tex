%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen,10pt,anonymous,review]{acmart}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{End-User Customization by Direct Manipulation of Tabular Data}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

\author{Geoffrey Litt}
\affiliation{%
  \institution{Massachusetts Institute of Technology}
  \city{Cambridge, MA}
  \country{USA}
}
\email{glitt@mit.edu}

\author{Daniel Jackson}
\affiliation{%
  \institution{Massachusetts Institute of Technology}
  \city{Cambridge, MA}
  \country{USA}
}
\email{dnj@csail.mit.edu}

\author{Tyler Millis}
\affiliation{%
  \institution{Massachusetts Institute of Technology}
  \city{Cambridge, MA}
  \country{USA}
}
\email{tmillis@mit.edu}

\author{Jessica Quaye}
\affiliation{%
  \institution{Massachusetts Institute of Technology}
  \city{Cambridge, MA}
  \country{USA}
}
\email{jquaye@mit.edu}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  In this paper we introduce \emph{table-driven customization}, a new
  way for end users to customize software. We augment a user interface
  with a table view showing the structured data inside the application.
  When users edit the table, their changes are reflected in the original
  UI. This simple model also accommodates a spreadsheet formula language
  and custom data editing widgets, providing enough power to implement a
  variety of useful extensions.

  We illustrate the approach with Wildcard, a browser extension that
  implements table-driven customization for existing applications using
  web scraping. Through concrete examples, we show that this paradigm
  can support extensions to many real websites, ranging from sorting and
  filtering existing data to adding entire new features. We share
  reflections from our experiences using Wildcard, on both its strengths
  and limitations relative to other customization approaches. Finally,
  we explore how this paradigm might lead to new software architectures
  that encourage this form of end-user customization.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%% From HERE
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011066.10011069</concept_id>
<concept_desc>Software and its engineering~Integrated and visual development environments</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Integrated and visual development environments}
% To HERE

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{end-user programming, software customization, web browser extensions}

%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
%\begin{teaserfigure}
%  \includegraphics[width=\textwidth]{sampleteaser}
%  \caption{Seattle Mariners at Spring Training, 2010.}
%  \Description{Enjoying the baseball game from the third-base
%  seats. Ichiro Suzuki preparing to bat.}
%  \label{fig:teaser}
%\end{teaserfigure}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

Many applications don't meet the precise needs of their users, and it is
impossible for developers to anticipate everyone's unique requirements.
End user customization systems can help close this gap, by empowering
non-programmers to modify their software to satisfy their personal
goals.

Many end user customization systems
\citep{cook2007, bolin2005, leshed2008, chasins2018} offer a scripting
model. They use various strategies to make programming more
approachable: friendly syntax, a visual programming environment, or
macro recording to bootstrap from concrete demonstrations. But all these
techniques build on the same fundamental foundation: an imperative
programming model, with statement sequencing, mutable variables, and
loops.

We have known for decades about an alternative: \emph{direct
manipulation} \citep{shneiderman1983}, where ``visibility of the object
of interest'' replaces ``complex command language syntax''. Direct
manipulation is the \emph{de facto} standard in GUIs today, but when it
comes to customizing those GUIs, it is rarely to be found. Switching
from using an interface to customizing it via scripting requires an
abrupt shift in interaction model, and can pose a steep learning barrier
for users not familiar with programming. We subscribe to MacLean et al's
vision of a ``gentle slope'' \citep{maclean1990}, where users should
only need to make minimal and incremental investments in skill to
achieve their desired customizations.

We seek to add a point to this gentle slope by proposing a new method
for customizing software via direct manipulation, which requires less
skill than scripting but still supports powerful customizations. We take
inspiration from visual database query interfaces and spreadsheets,
which have successfully enabled millions of end users to compute with
data through direct manipulation.

In this paper, we present a paradigm called \emph{table-driven
customization}. An application's UI is augmented with a table view where
the user can see and manipulate the application's internal data, just as
in a familiar spreadsheet. These changes don't just apply to the table;
they also result in immediate changes to the application's original user
interface. The user can sort/filter data in the UI, inject annotations
into the UI, pull in related information from other web services, and
more, all using the table as a mediating interface.

\begin{figure*}
\hypertarget{fig:overview}{%
\centering
\includegraphics[width=\textwidth]{media/overview.eps}
\caption{An overview of table-driven customization}\label{fig:overview}
}
\end{figure*}

We have developed a browser extension called Wildcard which uses web
scraping techniques to implement table-driven customization for existing
Web applications. In Section~\ref{sec:example}, we illustrate the end
user experience of table-driven customization through an example
scenario, using Wildcard to add features to Hacker News.

In Section~\ref{sec:architecture}, we explain the system architecture of
table-driven customization. We focus on the \emph{table adapter}
abstraction, which allows many different types of underlying data to be
bidirectionally mapped to a table. We describe several types of table
adapters we've built in Wildcard, and also describe future adapters
supported by the general paradigm.

We have successfully used Wildcard to build customizations for 11
different websites which serve our own personal needs. In
Section~\ref{sec:reflections}, we present reflections from this process.
We outline the kinds of customizations we were able to build,
limitations we encountered, and some of the challenges of writing
scraping logic.

In Section~\ref{sec:themes}, we discuss some key themes from our work:

\begin{itemize}
\tightlist
\item
  \emph{Customization by direct manipulation}: We agree with MacLean et
  al \citep{maclean1990} that customization should follow a ``gentle
  slope'', where users can gradually invest in more complex techniques
  to achieve deeper customizations. We believe an important point on
  this slope is the ability to customize an application by directly
  seeing and changing its internal structured data, rather than by
  writing imperative scripts.
\item
  \emph{Wrapping applications for customization}: Typically, tools that
  don't rely on official extension APIs resort to offering low-level
  APIs for customization. Instead, we propose a community-maintained
  library of semantic wrappers around existing applications, enabling
  end users to work with domain objects rather than low-level
  representations.
\end{itemize}

Table-driven customization relates to existing work in many areas. In
particular, our goals overlap with many software customization tools,
and our methods overlap with direct manipulation interfaces for working
with structured data, including visual database query systems and
spreadsheets. We explore these connections and more in
Section~\ref{sec:related-work}.

\hypertarget{sec:example}{%
\section{Example Scenario}\label{sec:example}}

To illustrate the end user experience of table-driven customization, we
consider an example scenario of customizing
\href{https://news.ycombinator.com/}{Hacker News}, a tech news
aggregator. Figure~\ref{fig:hacker-news} shows accompanying screenshots.

\begin{figure*}
\hypertarget{fig:hacker-news}{%
\centering
\includegraphics[width=\textwidth]{media/hacker-news.png}
\caption{Customizing Hacker News by interacting with a table view}\label{fig:hacker-news}
}
\end{figure*}

\textbf{Opening the table}: When the user opens Hacker News in a browser
equipped with the Wildcard extension, they see a table at the bottom of
the page. It contains a row for each link on the homepage, listing
information like the title, URL, submitter username, number of points,
and number of comments (Figure~\ref{fig:hacker-news}, Note A). The end
user didn't need to do any work to create this table, because a
programmer previously created an adapter to extract data from this
particular website, and contributed it to a shared library of adapters
integrated into Wildcard.

\textbf{Sorting by points}: First, the user decides to change the
ranking of links on the homepage. Hacker News itself uses a ranking
algorithm in which the position of an article depends not only on its
point count (a measure of popularity), but also on how long it has been
on the site. If the user hasn't been checking the site frequently, it's
easy to miss a popular article that has fallen lower on the list.
Sorting the page just by points would achieve a more stable ranking.

To achieve this ordering, the user simply clicks on the ``points''
column header in the table. This sorts the table view by points, and the
website UI also becomes sorted in the same order
(Figure~\ref{fig:hacker-news}, Note B)---Wildcard has manipulated the
website's DOM to synchronize it with the sort order of the table. This
sort order is also persisted in the browser and reapplied automatically
the next time the user loads the page, so they can always browse the
latest set of links using this sort order.

\textbf{Adding estimated read times}: Next, the user decides to attempt
a more substantial customization: to add estimated read times to
articles on Hacker News.

The table contains additional empty columns (\texttt{user1},
\texttt{user2}, \ldots), where the user can enter spreadsheet-like
formulas to compute derived values. The user enters a formula into the
first column: (Figure~\ref{fig:hacker-news}, Note C):

\begin{verbatim}
=ReadTimeInSeconds(link)
\end{verbatim}

This calls a built-in function that takes a URL as an argument and uses
a public web API to compute an estimated read time for the link's
contents. The \texttt{link} argument refers to a column name in the
table; the formula is automatically evaluated across all rows in the
table, using the value of \texttt{link} for each row.

The user clicks the \texttt{user1} column header to sort the articles on
the page in descending order of estimated read time, helping to
prioritize reading deeper content. It would be useful to show these read
times in the page too, but before doing that, the user wants to make the
time estimates more readable. They enter another formula in the next
column, \texttt{user2}:

\begin{verbatim}
=Concat(Round(user1/60), "min read")
\end{verbatim}

This formula converts seconds to minutes by dividing by 60 and rounding
to the nearest integer, and then concatenates a label to the number,
producing strings like ``21 min read''.

Finally, the user clicks a menu option in the table header to display
the contents of this new column in the original page
(Figure~\ref{fig:hacker-news}, Note D). Each article on the page now
shows an annotation with the estimated read time in minutes. (The format
of how annotations appear for each item was determined by the programmer
who created the Wildcard adapter for Hacker News.)

\textbf{Adding notes to links}: The user can also manually add notes to
the table, by simply entering values into the table without using
formulas. In this case, the user jots down a few notes in another column
about articles they might want to read, and the notes appear in the page
next to the read times (Figure~\ref{fig:hacker-news}, Note D). The
annotations are also stored in the browser's local storage so they can
be retrieved on future visits.

\textbf{Filtering out visited links}: Another way to use formulas to
customize Hacker News is to filter out articles the user has already
read. (We omit this example from the figure for brevity.) The user can
call a built-in function that returns a boolean depending on whether a
URL is in the browser's history:

\begin{verbatim}
=Visited(link)
\end{verbatim}

They can then filter the table to only contain rows where this formula
column contains \texttt{false}; visited rows are hidden both from the
table view and the original page. This is an example of a customization
that the original website could not implement, since websites don't have
access to the browser history for privacy reasons. But by using
Wildcard, the user can implement the customization locally, without
needing to expose their entire browser history to Hacker News.

This scenario has shown a few examples of how table-driven
customizations can help a user improve their experience of a website.
Section~\ref{sec:reflections} explains many other use cases, but first
we explain how the system works internally.

\hypertarget{sec:architecture}{%
\section{System architecture}\label{sec:architecture}}

\begin{figure}
\hypertarget{fig:table-adapter}{%
\centering
\includegraphics[width=\columnwidth]{media/table-adapter.eps}
\caption{The table adapter architecture}\label{fig:table-adapter}
}
\end{figure}

Figure~\ref{fig:table-adapter} summarizes the overall architecture of
table-driven customization, using a simplified illustration of the
Hacker News example scenario. In this example, the name and points value
for each article is scraped from the web page DOM, and user annotations
are loaded from the brower's local storage.

First, the web page and the browser storage are each wrapped by a
\textbf{table adapter}, which defines a bidirectional mapping between
some underlying data source and a table.

In addition to a \emph{read} mapping for how the underlying data should
be represented as a table, it also defines a \emph{write} mapping for
what effects edits should have on the original data source. In this
case, the local storage adapter has a trivial mapping: it loads a table
of data stored in the browser, and persists edits to that persisted
state. The mapping logic of the DOM scraping adapter is much more
involved. It implements web scraping logic to produce a table of data
from the web page, and turns edits into DOM manipulations, such as
reordering rows of data on the page.

The two tables are then combined into a single table for the end user to
view and edit. The \textbf{query engine} is responsible for creating
this combined view, and routing the user's edits back to the individual
table adapters. In this example, the query engine has joined the two
tables together by a shared ID column, and sorted the result by the
points column.

We now examine each component of the system in more detail.

\hypertarget{table-adapters}{%
\subsection{Table adapters}\label{table-adapters}}

A key idea in table-driven customization is that a wide variety of data
sources can be mapped to a generic table abstraction. In a relational
database, the table matches the underlying storage format, but in
table-driven customization, the table is merely an \emph{interface
layer}. The data shown in the table is a projection of some underlying
state, and edits to the table can have complex effects on the underlying
state.

Here we describe the abstract interface fulfilled by a table adapter,
and then describe specific types of table adapters we've built so far in
the Wildcard system.

\hypertarget{abstract-interface}{%
\subsubsection{Abstract interface}\label{abstract-interface}}

The first two parts of the table adapter interface resemble a typical
database table:

\emph{Returning a table}: A table adapter exposes a table of data: an
ordered list of records. Each record carries a unique identifier and
associates named attributes with values. Tables have a typed schema, so
the same attributes are shared across all records. We currently support
strings, numeric values, booleans, and datetimes as types. The columns
also carry some additional metadata, such as whether or not they are
read-only or editable.

A table adapter can update the contents of a table at any time in
response to changes in the underlying state (e.g., a DOM scraping
adapter can update the table when the page body changes). When data
changes, the query view is reactively updated in response.

\emph{Handling edits}: The query engine can issue a request to a table
adapter to make an edit to a record. The meaning of making an edit can
vary depending on the adapter: in the local storage adapter, an
annotation may be persisted into local storage; in the DOM scraping
adapter, an edit may represent filling in a form field.

In addition, the query engine also sends additional information about
the combined query view to each table adapter:

\emph{Sorting/filtering}: When the user sorts or filters the query view,
an ordered list of visible IDs is sent to each table adapter. The DOM
scraping adapter uses this information to change the list of rows shown
in the web page.

\emph{Data from other tables}: The query engine provides each table
adapter with the entire combined table shown to the user. The DOM
scraping adapter uses this for injecting annotations---values in
additional columns from other tables are added to the original web page.

\emph{Currently selected record}: As the user clicks in different parts
of the table view, the query engine communicates the record currently
selected by the user. The DOM scraping adapter uses this information to
highlight the row in the page that corresponds to the selected row in
the table (and scroll to the row if it's not currently showing on the
page), which helps clarify the connection between the table and the
original UI.

\hypertarget{dom-scraping-adapters}{%
\subsubsection{DOM scraping adapters}\label{dom-scraping-adapters}}

DOM scraping adapters are the essential component that enables Wildcard
to interface with an existing website UI. In addition to the standard
web scraping problem of extracting a table of data from the DOM, a
scraping adapter must also manipulate the DOM to reorder rows, edit form
entries, and inject annotations as the table is edited.

Because each website has unique content, we rely on programmers to
create a DOM scraping adapter for each individual website to make it
available for customization in Wildcard. To make this approach viable,
we have built a generic DOM scraping adapter which a programmer can
configure with the minimal site-specific parts.

\emph{Specifying scraping logic}: First, the adapter author specifies
basic metadata like which URLs the adapter should apply to, and a list
of columns and their types. Then, implement a single Javascript function
that extracts relevant elements from the page using web scraping
technqiues. The generic adapter then wraps this scraping function to
implement the table adapter interface. For example, when the user sorts
the table view, the generic adapter removes the DOM elements
corresponding to the rows in the table, and reinserts them back into the
page in the correct order.

For each scraped row of data, the programmer must return a unique
identifier, and a value for each column in the table.

\emph{Choosing an ID}: When possible, we recommend choosing a
server-side identifier that will remain stable across pageloads. This
enables user annotations persisted in local storage to be associated
with the same records on subsequent pageloads. We have found that it's
usually possible to find such an identifier; for example, each item in a
page often contains a link to a page with more details, where the URL
contains a unique identifier.

\emph{Types of scraped values}: For each individual value within a row,
there are two options for what type of data can be returned by the
programmer-specified scraping function.

The default option is to return a DOM element, in which case the generic
adapter extracts the text contents of the DOM element and casts them to
the type of the column. For example, if the relevant column is a numeric
column and the returned value is a \texttt{\textless{}div\textgreater{}}
containing the string ``1.23'', the generic adapter extracts the number
1.23. The advantage of this approach is that the field becomes
\emph{writable} in the table, if the adapter author chooses to mark it
as writable. When the user edits the value in the table, the generic
adapter can overwrite the inner contents of the DOM element to reflect
the change. In practice, this is most useful for editing the value of
form input fields. It's possible to enable the editing of other fields
(e.g., editing the title of a post on Hacker News) but we haven't found
many use cases for editing those types of fields.

Another option is to directly return a value, rather than returning a
DOM element. The advantage of this approach is that the adapter author
can perform arbitrary computations to derive the returned value---for
example, they can use a regular expression to extract a substring. The
disadvantage is that the field is no longer writable, because the
computation used to derive the value isn't reversible.

\emph{Other site-specific customization}: The programmer can optionally
override other behavior of the generic DOM scraping adapter, including
logic for when to re-run the scraping function in response to page
changes, how to style injected annotations, and how to style the
currently selected row in the table. We've chosen sensible defaults that
generally result in a workable adapter without needing to change these
options, but they can improve the experience on a specific website. For
example, by default we highlight the currently selected row with a blue
border, but on some sites this is hard to see or breaks the layout, so
setting a background color works better.

\hypertarget{ajax-scraping-adapters}{%
\subsubsection{AJAX scraping adapters}\label{ajax-scraping-adapters}}

An AJAX scraping adapter intercepts AJAX requests made by a web page,
and extracts information from those requests to add to the table. When
available, this tends to be a helpful technique because the data is
already in a structured form so it is easier to scrape, and it often
includes valuable information not shown in the UI.

As with DOM scraping adapters, we have made it easy for programmers to
create site-specific AJAX scraping adapters. A programmer writes a
function that specifies how to extract data from an AJAX request, and
the framework handles the details of intercepting requests and calling
the programmer-defined function.\footnote{So far we have only
  implemented AJAX scraping in the Firefox version of Wildcard, since
  Firefox has convenient APIs for intercepting requests. It appears
  possible to implement in Chrome as well, but we have not finished our
  implementation.}

In order to join the tables produced by AJAX scraping and DOM scraping,
a common set of identifiers is required across records in the two
tables. Often there is a server-defined ID present both in the DOM and
in AJAX responses; if not, the programmer can use some set of
overlapping data (e.g.~an item name) as a shared ID.

\hypertarget{local-storage-adapters}{%
\subsubsection{Local storage adapters}\label{local-storage-adapters}}

The local storage adapter simply stores a table of data in the browser.
This is currently only used to persist annotations.

The table view is initialized with empty columns such as \texttt{user1}
which serve as the user's ``scratch space,'' as shown in
Section~\ref{sec:example}. When the user makes edits to these columns,
new rows are created in the local storage table. The rows contain the
record ID from the DOM scraping adapter, which enables them to be
re-associated with the same records on subsequent pageloads.

\hypertarget{future-adapters}{%
\subsubsection{Future Adapters}\label{future-adapters}}

We have designed the table adapter API to be general enough to support
other types of useful adapters in the future. Here are two examples:

\textbf{Integrated website adapters}: A key benefit of the table adapter
abstraction is that Wildcard is not coupled to web scraping as the only
means for integrating with existing sites, but can also accommodate
first party developers adding support directly into their own websites.
An ``integrated website adapter'' installed by the developer could
directly accesses the internal state of the application, providing the
same functionality as a DOM scraping adapter but in a more robust way.

With the advent of rich frontend web frameworks, structured application
state is now often available in the web client. We suspect it is
possible to create plugins for frontend frameworks that expose this
state to Wildcard with only minimal effort from the application
developers. To test this hypothesis, we have created an early prototype
of a Wildcard adapter for the Redux state management library, and used
it with the TodoMVC todo list application. To install the adapter, the
programmer only needs to make a few small changes to their app:

\begin{itemize}
\tightlist
\item
  \emph{Exposing a table}: In Redux, app developers already represent
  the state of a user interface as a single object. To expose a table of
  data, the developer simply writes a function that maps the state
  object to a table.
\item
  \emph{Editing data values}: The developer defines how edits to records
  in the table should map to edits in the state object.
\item
  \emph{Sorting/filtering the UI}: The developer inserts an additional
  data processing step before the state object is rendered in the UI, so
  that Wildcard can apply sorting and filtering.
\item
  \emph{Annotations}: The developer adds additional React components
  managed by Wildcard into their UI tree, which render additional data
  as annotations.
\end{itemize}

Customizability is sometimes a key selling point for software. An
integrated website adapter would provide a way for developers to
integrate with an ecosystem of formulas and customization tools without
needing to build all that functionality from scratch.

\textbf{Shared storage adapter}: It would be useful to share user
annotations among users and across devices---for example,
collaboratively taking notes with friends on options for places to stay
together on a trip. The existing local storage adapter could be extended
to share live synchronized data with other users. This could be achieved
through a centralized web server, or through P2P connections that might
provide stronger privacy guarantees.

\hypertarget{query-engine}{%
\subsection{Query engine}\label{query-engine}}

The query engine is responsible for coordinating across multiple table
adapters. It joins data across multiple tables and creates a single
result table which is shown to the user through the editor. It also
handles all user interactions and routes appropriate messages to each
table adapter.

Queries are processed in three steps. First, the query invokes a primary
DOM scraping adapter that associates table rows with elements in the
application's user interface. Next, additional tables (AJAX data, local
storage data) are left-joined by ID. Finally, the result table is sorted
and filtered according to user-specified predicates.

One way to view this query model is as a tiny subset of the SQL query
model. Despite its simplicity, this model has proven sufficient for
meeting the needs of customization in practice, and minimizes the
complexity of supporting arbitrary queries. But because it fits into the
general paradigm of relational queries, it could theoretically be
extended to support a wider range of queries.

The query engine is also responsible for executing formulas. We have
built a small formula language resembling a spreadsheet formula
language, except that formulas automatically apply across an entire
column of data, and reference other column names instead of values in
specific rows. This is more convenient than needing to copy-paste a
formula across an entire column as in spreadsheets, and has worked for
all of the customizations we have built.

\hypertarget{table-editor}{%
\subsection{Table editor}\label{table-editor}}

We provide a basic table editor as the user interface on top of the
query engine. Our table editor is built with the Handsontable Javascript
library, which provides UI elements for viewing, editing, sorting, and
filtering a table.

In addition to the basic table editing operations, we also provide
\emph{cell editors}: UI widgets that expose a custom editing UI for a
single cell of the table view. A programmer building a cell editor need
only integrate it with the table viewer; propagating values into the
website UI is handled by the site-specific DOM adapter. In
Section~\ref{sec:reflections} we provide some examples of using cell
editors.

The table editor only serves as a shallow interface layer over the query
engine, relaying user commands to the query engine and rendering the
resulting data table. Because of this architectural split, it would be
straightforward to develop additional table editor interfaces on top of
the Wildcard system. One intruiging future possibility is to apply the
idea of cell editors to the entire table, by developing table editors
which don't look like a table. For example, we could provide a calendar
view for displaying a table containing a date column.

\hypertarget{sec:reflections}{%
\section{Reflections on Usage}\label{sec:reflections}}

\begin{table*}[]
\begin{tabular}{llrl}
\hline
\textbf{Website} & \textbf{Description} & \textbf{LOC} & \textbf{Example customizations}                                                              \\ \hline
Airbnb           & Travel               & 73                                       & Add Walkability Scores to listings. Sort listings by price.                           \\
Amazon           & Online shopping      & 99                                       & Sort third party sellers by total price, including fees.                                \\
Blogger          & Blogging             & 36                                       & Use alternate text editor to edit blog posts.                                                 \\
Expedia          & Travel               & 41                                       & Use alternate datepicker to enter travel dates.                                               \\
Flux             & Data portal          & 67                                       & Use Wildcard as a faster table editor for editing lab results.                                \\
Github           & Code repository      & 62                                       & Sort a user's code repositories by stars to find popular work.                                \\
Hacker News      & News                 & 69                                       & Add read times to links. Filter out links that have been read. \\
Instacart        & Grocery delivery     & 48                                       & Sort groceries by price and category. Take notes on items.                                   \\
Uber Eats        & Food delivery        & 117                                      & Sort/filter restaurants by estimated delivery ETA and price.                                 \\
Weather.com  & Weather              & 51                                       & Sort/filter hourly weather to find nice times of day.                                        \\
Youtube          & Videos               & 80                                       & Sort/filter videos by length, to find short videos to watch.                                 \\ \hline
\end{tabular}
\caption{A list of table-driven customizations that we have implemented using Wildcard.}
\label{tab:websites}
\end{table*}

To evaluate table-driven customization in practice, we built the
Wildcard browser extension, which implements table-driven customization
in the context of existing websites. It is implemented in Typescript,
and works across three major browsers: Chrome, Firefox, and Edge.

We built Wildcard integrations for 11 websites, including transactional
sites like Amazon and Uber Eats, and media consumption sites like
Youtube and Hacker News. Table 1 summarizes these integrations, showing
the number of lines of code in the adapter configuration for each site,
and some example customizations we were able to perform for each site.

So far, most usage of Wildcard has come from members of the project
team. Here we offer our reflections on using the system, focused on two
key questions:

\begin{itemize}
\tightlist
\item
  How broad is the range of possible customizations in this paradigm?
\item
  How feasible is it to build DOM scraping adapters for real websites?
\end{itemize}

\hypertarget{range-of-customizations}{%
\subsection{Range of customizations}\label{range-of-customizations}}

We have found that table-driven customization can serve a broad range of
useful purposes. Here we expand on some archetypal examples that
illuminate aspects of using the system in practice.

\hypertarget{sortingfiltering}{%
\subsubsection{Sorting/filtering}\label{sortingfiltering}}

It might seem that most websites already have adequate sorting and
filtering functionality, but we have found it surprisingly helpful to
add new sorting/filtering functionality to websites using Wildcard.

Sometimes, websites have opaque ranking algorithms which presumably
maximize profit but don't offer much control to the user. For example,
Airbnb previously allowed users to sort listings by price, but removed
that feature in 2012. We have found other sites where a lack of sorting
options seems more like merely an omission; for example, the Instacart
grocery delivery service has a spartan UI for viewing a pending order,
which doesn't allow for sorting by price or category. In both of these
cases, Wildcard enables users to take back some control.

In the current implementation of Wildcard, users can only sort and
filter entries that are shown on the current page, which means that
users are not entirely liberated from the suggestions of the opaque
algorithm. This restriction could be overcome in the future by scraping
content across multiple pages, or by using an integrated adapter built
in to the application. However, we've also found that sorting/filtering
a single page of a paginated list is often an acceptable outcome (and
sometimes even a preferable one). It's more useful, for example, to sort
30 recommended Youtube videos than to try to sort all videos on Youtube.

\begin{figure}
\hypertarget{fig:amazon}{%
\centering
\includegraphics[width=\columnwidth]{media/amazon.png}
\caption{Sorting the used sellers page on Amazon by total price}\label{fig:amazon}
}
\end{figure}

\begin{figure}
\hypertarget{fig:ubereats}{%
\centering
\includegraphics[width=\columnwidth]{media/ubereats.png}
\caption{Organizing takeout restaurants on Uber Eats by ETA and price}\label{fig:ubereats}
}
\end{figure}

\hypertarget{annotating}{%
\subsubsection{Annotating}\label{annotating}}

Many web annotation systems focus on annotating text or arbitrary
webpage content, but Wildcard limits annotations to structured objects
extracted by an adapter, resulting in a different set of use cases.
Annotating with Wildcard has proven most useful when taking notes on a
list of possible options (e.g., evaluating possible Airbnb locations to
rent). We have also used it with Instacart's online grocery cart, for
jotting down notes like ``do we need more eggs?''

\hypertarget{formulas}{%
\subsubsection{Formulas}\label{formulas}}

Formulas are the most powerful part of the Wildcard system. So far, our
language supports only a small number of predefined functions. Adding
more should allow a broad range of useful computations, as shown by the
success of spreadsheets.

Formulas are especially useful for fetching data from Web APIs. We've
used them to augment Airbnb listings with walkability scores, and to
augment Hacker News articles with estimated read times as shown in
Section~\ref{sec:example}. One challenge of the current language design
is that supporting a new web API requires writing Javascript code to add
a new function to the language, because web APIs typically return
complex JSON data structures that can't be easily displayed in a single
table cell. In the future we would like to make it possible to call new
APIs without adding a dedicated function, which might require adding
functions to the formula language that can manipulate JSON data.

We have also found instances where simple data manipulation is useful,
e.g.~transforming the results of an API call with basic arithmetic and
string operations, as shown in Section~\ref{sec:example}.

\begin{figure}
\hypertarget{fig:instacart}{%
\centering
\includegraphics[width=\columnwidth]{media/instacart.png}
\caption{Taking notes on Instacart grocery items, after sorting them by price}\label{fig:instacart}
}
\end{figure}

\hypertarget{cell-editors}{%
\subsubsection{Cell editors}\label{cell-editors}}

We developed two cell editors to explore different benefits of adding
custom UI for editing the table.

An important benefit of cell editors is that they allow users to
incorporate their private information into a web UI without uploading it
to a website. To explore this idea, we created a datepicker based on the
\href{https://fullcalendar.io/}{FullCalendar} plugin, which can load
data from a Google Calendar. This makes it convenient to enter dates
into a website based on the user's personal calendar information.

Another benefit of cell editors is that a user can choose their
preferred widget for editing some type of information. We built a text
editor based on the \href{https://ckeditor.com/}{CKEditor} rich text
editor, and demonstrated its use by integrating it with Google's Blogger
website and using it to edit blog post content.

\begin{figure}
\hypertarget{fig:blogger}{%
\centering
\includegraphics[width=\columnwidth]{media/blogger.png}
\caption{Using a custom text editor widget to edit a blog post on Blogger. The text is synchronized with the Blogger editor through a table cell.}\label{fig:blogger}
}
\end{figure}

\hypertarget{limitations}{%
\subsubsection{Limitations}\label{limitations}}

There are many customizations that are not possible to implement with
table-driven customization. Some of the limitations are specific to the
current implementation of the Wildcard extension, but many are more
fundamental to the general paradigm.

One limitation is that Wildcard can only make customizations that use
the available data exposed in the table. If the adapter doesn't expose
some piece of data, the user can't use it in their customization. The
table data format also rules out customizing certain sites that don't
have a way to map to a table. The UI modifications available in Wildcard
are also limited in scope; deleting arbitrary buttons isn't possible,
for example. There is no facility for running automations when the user
isn't actively viewing a page---at one point, we wanted to build an
automation to repeatedly load a grocery delivery website to check for
open delivery slots, but it didn't seem possible to achieve this in
Wildcard.

We consider these limitations to be an acceptable outcome. Our goal is
to support as many useful customizations as possible with a low
threshold of difficulty, and not to span all possible customizations. If
users want to implement more sophisticated customizations, they have the
option of graduating to more advanced customization tools like scripting
languages.

We have found that one benefit of showing structured data is
predictability: once we build an adapter for a website, it is clear what
data is available or unavailable for use in customizations. Also, there
is sometimes a way to reframe an imperative script in terms of our
direct manipulation model. For example, a script that iterates through
rows in a page adding some additional information to each row can be
reproduced using a single formula in Wildcard.

\hypertarget{viability-of-scraping}{%
\subsection{Viability of scraping}\label{viability-of-scraping}}

Our second evaluation area relates less to the conceptual approach of
table-driven customization, and more to the specific implementation of
customizing existing web applications. In order for third-party
customization through Wildcard to succeed, it is important that creating
usable adapters for existing websites takes minimal effort.

Nearly all of our DOM scraping adapters were created by members of our
team. However, an external developer unaffiliated with the project
contributed one adapter, designed to sort the Github page listing a
user's repositories, and they described the experience as ``very
straightforward.''

The adapters for our test sites ranged from 36 to 117 lines of code,
averaging 68 lines; Table 1 shows the number of lines of code for each
adapter. Most of the code in the adapters is simply using DOM APIs and
CSS selectors to implement conventional web scraping logic.

Some of the challenges of writing a DOM scraping adapter are the same
ones as with writing normal web scraping code, but the more interactive
nature of Wildcard introduces additional challenges. One challenge is
registering appropriate event handlers to update the table data in
response to UI changes that happen after initial page load. Another
challenge is persisting updates to the DOM---some websites use virtual
DOM frameworks that can occasionally overwrite changes made by Wildcard.
So far, in practice we've managed to work around these issues for all of
the websites we've tried, but we don't claim that any website can be
customized through DOM scraping. As web frontend code gets increasingly
complex (and starts to move beyond the DOM to other technologies like
Shadow DOM or even WebGL), it may become increasingly difficult to
customize websites from the outside without first-party support.

AJAX scraping proved highly useful in several cases. The Uber Eats
website was challenging to scrape because it has a complex DOM structure
with machine-generated CSS classes, but the site also use AJAX requests
which contain all the relevant data in a structured form that is much
easier to extract. We also found examples where relevant information
wasn't present in the DOM at all. On the grocery delivery site
Instacart, we found that AJAX requests contained additional data not
shown in the UI, enabling us to do things like sort grocery items in an
order by category.

\hypertarget{sec:themes}{%
\section{Key themes}\label{sec:themes}}

Here we discuss some themes that we've explored with this work, which go
beyond our specific approach and address issues in software
customization more broadly.

\hypertarget{sec:dm}{%
\subsection{Customization by direct manipulation}\label{sec:dm}}

Hutchins, Hollan and Norman \citep{hutchins1985} define a direct
manipulation interface as one that uses a model-world metaphor rather
than a conversation metaphor. Instead of presenting an ``assumed'' but
not directly visible world that the user converses with, ``the world is
explicitly represented'' and the user can ``{[}act{]} upon the objects
of the task domain themselves.''

Although most GUIs today employ direct manipulation, software
customization tools typically use an imperative programming model, which
implements the conversational metaphor rather than direct manipulation.
Here, for example, is how a user retrieves a list of of calendar names
from the Calendar application in Applescript \citep{cook2007}, the
scripting language for customizing Mac OS applications:

\begin{verbatim}
tell application "Calendar"
  name of calendars
end tell
\end{verbatim}

Some customization environments like Mac Automator and Zapier forego
textual syntax and let the user connect programs and construct
automations by dragging and dropping icons representing commands. These
environments still do not constitute direct manipulation, though: the
objects being manipulated are in the domain of programming, not in the
domain of the task at hand.

Imperative programming is a reasonable choice as the model for building
customizations. Turing-complete programming provides a high ceiling for
possible customizations, and a sequence of commands is a natural fit for
automations that simulate a series of steps taken by the user. There is,
however, a serious drawback to this approach. MacLean et al
\citep{maclean1990} describe an ideal for user-tailorable systems: a
``gentle slope'' from using to customizing, where small incremental
increases in skill lead to corresponding increments of customization
power. Requiring users wanting to customize their applications to learn
programming creates an abrupt ``cliff,'' exacting a significant
investment in learning even to implement the simplest customizations.
Another goal of MacLean et al is to make it ``as easy to change the
environment as it is to use it''---at least for some subset of changes.
But in scripting languages, the experience of customization does not
remotely resemble the experience of use.

With table-driven customization we aim to provide a gentler slope, by
using direct manipulation for software customization. The data shown in
the table view is the domain data from the original application. The
user makes changes to the data by selecting areas of interest in the
table, e.g.~sorting/filtering by clicking the relevant column header, or
adding annotations by clicking on the relevant row. These interactions
are common in GUI applications, and Wildcard therefore meets MacLean et
al's goal: some one-click customizations are as easy as using the
original application. Formulas introduce some additional complexity, but
the pure functional semantics and the intermediate visibility of results
make the task still easier than imperative programming.

One aspect of directness that we have chosen not to maintain in Wildcard
is enabling customization in closer proximity to the original user
interface elements, as explored by tools like Scotty \citep{eagan2011}.
We have found that augmenting the original UI with a distinct,
additional representation provides a more consistent experience across
all applications, and clearly shows the user what structured data is
available to work with.

Ainsworth et al provide a helpful taxonomy of the value of multiple
representations \citep{ainsworth1999}. In their terms, Wildcard plays a
\emph{complementary role} by supporting a \emph{different set of tasks}
from the original application, while displaying \emph{shared
information}. Wildcard may also help construct \emph{deeper
understanding by subtraction}. By stripping away details and only
showing the essential data in an interface, Wildcard helps users think
of new ways of using that data, outside the specific constraints of the
original application.

As noted in Section~\ref{sec:reflections}, there are many customizations
that can be achieved in scripting languages that cannot be implemented
in Wildcard. We consider this an acceptable tradeoff in exchange for a
gentler slope in customization, and we show in Section~\ref{sec:example}
and Section~\ref{sec:reflections} that our model can still implement
many useful customizations.

\hypertarget{semantic-wrappers}{%
\subsection{Semantic wrappers}\label{semantic-wrappers}}

\emph{Ad hoc customization tools} enable customization without using
official extension APIs, enabling a broader range of customizations on
top of more applications. For example, web browser extensions have
demonstrated the utility of customizing websites through manipulating
the DOM, without websites needing to provide explicit extension APIs.
However, ad hoc customization comes with a cost: these tools typically
operate at a low level of abstraction, e.g.~manipulating user interface
elements, rather than in a meaningful domain model. This makes it harder
for end users to write scripts, and makes the resulting scripts more
brittle as the specifics of a user interface change.

\emph{Anticipated customization tools}, in contrast, use explicit
extension APIs provided by the application developer. Examples of this
include accessing a backend web API, or writing a customization in
Applescript for an application that exposes its domain model to the
scripting language. The main benefit of this style is that it allows the
extension author to work with meaningful concepts in the application
domain---``create a new calendar event'' rather than ``click the button
that contains the text `new event'.''---which makes customizations
easier to build and more robust. However, the plugin API limits the
types of customizations that can be built, and many applications don't
have an extension system at all.

With Wildcard, we use a hybrid approach that aims to provide the best of
both worlds. Programmers implement site-specific adapters that are
internally implemented ad hoc customizations, but externally provide a
high-level interface to the application, abstracting away the details of
the user interface. These wrappers are added to a shared repository,
available to all users of the system. When an end user is using a site
that already has an adapter implemented, they benefit from a semantic
customization experience that avoids low-level details.

One way to view this approach is as introducing a new abstraction
barrier into third-party extension. Typically, a third party
customization script combines two responsibilities: 1) mapping the
low-level details of a user interface to semantic constructs (e.g.,
using CSS selectors to find certain page elements), and 2) handling the
actual logic of the specific customization. Even though the mapping
logic is often more generic than the specific customization, the
intertwining of these two responsibilities in a single script makes it
very difficult to share the mapping logic across scripts.

With Wildcard we propose a decoupling of these two layers: a repository
of shared wrappers maintained by programmers, and a separate repository
of specific customizations built on top of these wrappers. This general
architecture has been successfully demonstrated by projects like
\href{https://github.com/KartikTalwar/gmail.js/}{Gmail.js}, an open
source project that creates a convenient API for browser extensions to
interface with the Gmail web email client.

The success of semantic wrappers depends on a key hypothesis: that a
single wrapper created by a programmer can be used for many different
purposes by end users. Although we've validated that a single generic
adapter can support many customizations, so far the people making the
adapters have largely been the same people building customizations on
top of them. One helpful future addition would be to allow end users to
create wrappers themselves, or at least to modify existing ones. There
are many existing projects exploring end-user web scraping (such as
Helena \citep{chasins2018}) which might prove helpful for this.

The distribution mechanism for semantic wrappers is also important.
Currently, the distribution mechanism is simply merging the code for all
adapters into the main Wildcard codebase. This is the simplest workable
solution, but has its downsides: contributing involves a fairly high
barrier of creating a pull request on Github, and using newly
contributed wrappers requires installing a new version of the extension.
In the future we might explore other mechanisms, like an online
repository that the extension pulls from dynamically. Security is also a
consideration---DOM scraping adapters can execute arbitrary Javascript
code, which opens up the possibility of malicious adapters being
contributed. Currently we plan to solve this challenge with centralized
code review, but another approach we are considering is using or
inventing a more restricted domain-specific language for specifying
scraping logic.

\hypertarget{sec:related-work}{%
\section{Related Work}\label{sec:related-work}}

This paper extends work reported in a workshop paper by Litt and Jackson
\citep{litt2020} which presented an earlier version of the Wildcard
extension. We have substantially extended their work in this paper by
creating the table adapter abstarction, reimplementing the internals of
Wildcard around that abstraction, evaluating the system on many more
websites, and by characterizing the design of the system in much more
detail than in their workshop paper.

Table-driven customization relates to two broad areas of related work.
Our problem statement is related to software customization tools, and
our solution approach is related to spreadsheets and other direct
manipulation interfaces.

\hypertarget{customization-tools}{%
\subsection{Customization tools}\label{customization-tools}}

Table-driven customization is most closely related to other tools that
aim to empower end users to customize software without traditional
coding.

This lineage goes back at least to the Buttons system by MacLean et al
\citep{maclean1990}, where Xerox Lisp users could share buttons that
performed various ``tailoring'' actions on the system. The authors
proposed the ``gentle slope'' idea which has greatly influenced our
approach to table-driven customization (as discussed in
Section~\ref{sec:dm}). The authors also point out the importance of a
``tailoring culture'' where people with different skillsets collaborate
to produce useful customizations; in their system, Lisp programmers
create buttons that others can use, modify, and rearrange. This division
of labor corresponds to our idea of semantic wrappers, where end user
customization is supported by programmer-created building blocks.

Some recent web customization tools aim to enable end users to modify
web interfaces without programming.

Sifter \citep{huynh2006} enables end users to sort and filter lists of
data obtained by web scraping, much like Wildcard's sorting features.
The main difference between the systems is that table-driven
customization has many other use cases besides sorting and filtering.
Also, Sifter involves end users in a semi-automated data extraction
process, rather than having programmers create wrappers. This provides
coverage of more websites, but at the expense of complicating the end
user experience. We could integrate end user scraping techniques in
Wildcard in the future, but we believe that when possible it's valuable
for end users to have a customization experience decoupled from the
challenge of web scraping the underlying data. Sifter also implements
scraping across multiple pages, a valuable feature for sorting and
filtering that isn't present in Wildcard.

Thresher \citep{hogue2005} helps end users create wrappers that map
website content to Semantic Web schemas like ``Movie'' or ``Director,''
and augments websites with new functionality by exploiting that schema
information. Wildcard shares the general idea of wrappers, but maps to a
generic table data type rather than more specific schemas, increasing
the range of supported data and allowing for a simpler mapping process.

There are many software customization tools that offer simplified forms
of programming for end users. Chickenfoot \citep{bolin2005} and
Coscripter \citep{leshed2008} offer user friendly syntax for writing web
automation scripts; Applescript \citep{cook2007} has a similar goal for
desktop customization. There are visual programming environments for
customization that don't involve writing any text:
\href{https://support.apple.com/guide/automator/welcome/mac}{Automator}
for Mac and
\href{https://apps.apple.com/us/app/shortcuts/id915249334}{Shortcuts}
for iOS are modern options for customizing Apple products, and
\href{https://zapier.com/}{Zapier} enables users to connect different
web applications together visually. As mentioned previously, these tools
all require writing imperative programs, in contrast to the more
declarative and direct approach of table-driven customization.

\hypertarget{direct-manipulation-programming-interfaces.}{%
\subsection{Direct manipulation programming
interfaces.}\label{direct-manipulation-programming-interfaces.}}

Another relevant area involves spreadsheets and visual query systems. We
take inspiration from these tools in our work, but apply them in a
different domain: customizing existing software applications, rather
than interacting with databases or constructing software from scratch.

The most closely related work is in systems that offer spreadsheet-like
querying of relational data. SIEUFERD by Bakke and Karger
\citep{bakke2016} is one such recent system, and their paper presents a
survey of many other similar tools. Our work is particularly influenced
by the authors' observation that direct manipulation requires that the
user manipulate the results of a database query rather than the query
itself, and that the user must see intermediate results at every step of
constructing the query. SIEUFERD's interface supports a far wider range
of queries than Wildcard, but the fundamental principles of the user
interface are similar. \href{https://airtable.com/}{Airtable} is another
example of a modern commercial product that offers spreadsheet-like
interaction with a relational database.

Our work is also inspired by the many projects that have explored using
spreadsheets as a foundation for building software applications,
including Object Spreadsheets \citep{mccutchen2016}, Quilt
\citep{benson2014}, Gneiss \citep{chang2014}, Marmite \citep{wong2007},
\href{https://www.glideapps.com/}{Glide}. We share the core idea of
connecting a spreadsheet view to a GUI, but apply it to software
customization, rather than building software from scratch.

Another related system is ScrAPIr, by Alrashed et
al.~\citep{alrashed2020}, which enables end users to access backend web
APIs without programming. ScrAPIr shares our high level goal of end user
empowerment, as well as the idea of wrappers, by creating a shared
library of wrappers around existing web APIs. Unlike Wildcard, however,
ScrAPIr targets explicit APIs exposed by developers. It also focused on
backend services and doesn't aim to extend the frontend interfaces of
web applications.

\hypertarget{sec:conclusion}{%
\section{Conclusion and Future Work}\label{sec:conclusion}}

In this paper, we have presented table-driven customization, a new
paradigm for customizing software by direct manipulation of the
underlying structured data. We have demonstrated the paradigm using a
browser extension, and have used it to create useful customizations for
a variety of websites.

Our primary goal for future work is to evaluate the system with a
broader group of users. What barriers do end users face when using the
system? What types of customizations do they choose to create? What
formulas prove most helpful?

Another area for future work is exploring whether it is possible to
express a broader range of customizations by extending our table-editing
paradigm. Are there ways to offer an increase in power and functional
complexity, while retaining a programming model that is simpler for end
users than conventional coding?

As computing plays an ever greater role in our lives, it is increasingly
important that end users have agency over the behavior of their
software, rather than having every detail be dictated by companies whose
incentives are not always aligned with the user's interests. We hope
that table-driven customization can serve as one point, and maybe a
guidepost, on our path from normal use to deep modification, in support
of a more adaptable experience for all computer users.

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{wildcard-onward-bibtex.bib}

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
